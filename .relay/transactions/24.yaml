uuid: 44026bb4-5b43-455b-8016-168a2ab34a83
projectId: noca-flow
createdAt: '2025-11-12T03:54:17.782Z'
gitCommitMsg: >-
  chore: Enforce and apply eslint rules

  This commit implements linting across the codebase by: - Updating the `lint`
  script in package.json to include the `test/` directory. - Fixing all existing
  eslint violations, including unused variables, unused imports, and explicit
  `any` types. - This ensures a consistent code style and quality for both
  application and test code.
promptSummary: Implement eslint by fixing linting errors and updating the lint script.
reasoning:
  - >-
    Based on your request to "Implement eslint," I will update the project to be
    fully compliant with the existing ESLint rules. This involves fixing linting
    errors in the source code, such as unused variables and forbidden types, and
    expanding the linting script to cover test files, ensuring a consistent code
    quality across the entire TypeScript codebase.
  - >-
    First, I'll update the `lint` script in `package.json` to include the `test`
    directory. This ensures that our tests adhere to the same quality standards
    as our application code.
  - >-
    Next, I'll address the unused `argv` parameter in the command handlers.
    According to our ESLint configuration, unused variables should be prefixed
    with an underscore.
  - I'll apply the same fix to the `state` command handler.
  - >-
    Now I'll fix the issues in the utility files. In `src/utils/fs.ts`, there's
    an unused import and an explicit `any` type in a `catch` block, which
    violates our ESLint rules. I will remove the import and the type annotation,
    allowing TypeScript's strict mode to correctly infer the error type as
    `unknown`.
  - >-
    Finally, `src/utils/shell.ts` has unused imports from `plan.ts`. I will
    remove them to clean up the file.
  - >-
    These changes will make the codebase compliant with the configured ESLint
    rules and improve overall code quality.
operations:
  - type: write
    path: package.json
    content: |
      <<<<<<< SEARCH
          "lint": "eslint 'src/**/*.ts'"
      =======
          "lint": "eslint 'src/**/*.ts' 'test/**/*.ts'"
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/commands/init.ts
    content: |+
      --- src/commands/init.ts
      +++ src/commands/init.ts
      @@ -5,7 +5,7 @@
       /**
        * @description Handles the logic for the 'init' command.
        */
      -export const handleInitCommand = async (argv: {}): Promise<void> => {
      +export const handleInitCommand = async (_argv: {}): Promise<void> => {
         const rootDir = '.nocaflow';
         try {
           await fs.access(rootDir);

    patchStrategy: standard-diff
  - type: write
    path: src/commands/state.ts
    content: |+
      --- src/commands/state.ts
      +++ src/commands/state.ts
      @@ -10,7 +10,7 @@
       /**
        * @description Displays the full state report to the console.
        */
      -export const handleStateCommand = async (argv: {}): Promise<void> => {
      +export const handleStateCommand = async (_argv: {}): Promise<void> => {
         const phaseStats: PhaseStats = await getPhaseStats();
         const activeAgents: AgentInfo[] = await getActiveAgents();
         const recentLogs: LogEntry[] = await getRecentLogs(5);

    patchStrategy: standard-diff
  - type: write
    path: src/utils/fs.ts
    content: |+
      --- src/utils/fs.ts
      +++ src/utils/fs.ts
      @@ -2,9 +2,7 @@
       import fs from 'fs/promises';
       import yaml from 'js-yaml';
       import dayjs from 'dayjs';
      -import { YAMLException } from 'js-yaml';
       import { Plan } from '../models/plan';
       
       export interface PhaseStats {
      @@ -105,7 +103,7 @@
           const fileContent = await fs.readFile(filePath, 'utf-8');
           const plan = yaml.load(fileContent) as Plan;
           return plan;
      -  } catch (error: any) {
      +  } catch (error) {
           // Let the caller handle the error. They might want to know if it's a
           // file not found vs. a parsing error.
           throw error;

    patchStrategy: standard-diff
  - type: write
    path: src/utils/shell.ts
    content: |+
      --- src/utils/shell.ts
      +++ src/utils/shell.ts
      @@ -2,7 +2,6 @@
       import { exec as execCallback } from 'child_process';
       import dayjs from 'dayjs';
       import relativeTime from 'dayjs/plugin/relativeTime';
      -import { Plan, PlanPart } from '../models/plan';
       
       export interface AgentInfo {
         phase: 'INIT' | 'DEV' | 'QA' | 'SCAF';

    patchStrategy: standard-diff
snapshot:
  src/utils/fs.ts: >-
    import path from 'path';

    import fs from 'fs/promises';

    import yaml from 'js-yaml';

    import dayjs from 'dayjs';

    import { YAMLException } from 'js-yaml';

    import { Plan } from '../models/plan';


    export interface PhaseStats {
      [phaseName: string]: {
        todo: number;
        doing: number;
        review: number;
        failed: number;
        done: number;
        total: number;
      };
    }


    export interface FailedReport {
      planId: string;
      partId: string;
      reason: string;
      reportPath: string;
    }


    /**
     * @description Reads all plan files from all phases and aggregates stats.
     * @returns An object containing plan counts for each status in each phase.
     */
    export const getPhaseStats = async (): Promise<PhaseStats> => {
      const phases = ['initialization', 'development'];
      const statuses: (keyof PhaseStats[string])[] = [
        'todo',
        'doing',
        'review',
        'failed',
        'done',
      ];
      const stats: PhaseStats = {};

      for (const phase of phases) {
        stats[phase] = { todo: 0, doing: 0, review: 0, failed: 0, done: 0, total: 0 };
        for (const status of statuses) {
          const dirPath = path.join('.nocaflow', phase, 'plans', status);
          try {
            const files = await fs.readdir(dirPath);
            // A plan is represented by its .yml file. This counts plans in each state directory.
            const count = files.filter(f => f.endsWith('.yml')).length;
            stats[phase][status] = count;
            stats[phase].total += count;
          } catch (error) {
            // Directory likely doesn't exist, count is 0.
          }
        }
      }
      return stats;
    };


    /**
     * @description Scans the failed reports directory for recent failures.
     * @param hours - The lookback period in hours.
     * @returns A list of failed report details.
     */
    export const getFailedReports = async (hours: number):
    Promise<FailedReport[]> => {
      const phases = ['initialization', 'development'];
      const reports: FailedReport[] = [];
      const since = dayjs().subtract(hours, 'hour');

      for (const phase of phases) {
        const reportDir = path.join('.nocaflow', phase, 'plans', 'failed', 'report');
        try {
          const files = await fs.readdir(reportDir);
          for (const file of files) {
            if (!file.endsWith('.report.md')) continue;
            const filePath = path.join(reportDir, file);
            const stats = await fs.stat(filePath);
            if (dayjs(stats.mtime).isAfter(since)) {
              const content = await fs.readFile(filePath, 'utf-8');
              const summaryMatch = content.match(/## Summary\s*\n\s*([\s\S]*?)(?=\n##|$)/);
              const reason = summaryMatch ? summaryMatch[1].trim() : 'Could not parse summary.';
              const [planId, partId] = file.split('.').slice(0, 2);
              reports.push({ planId, partId, reason, reportPath: filePath });
            }
          }
        } catch (error) {
          // dir may not exist
        }
      }
      return reports;
    };


    /**
     * @description Reads and parses a YAML plan file.
     * @param filePath - The path to the plan.yml file.
     * @returns The parsed Plan object.
     */
    export const readPlan = async (filePath: string): Promise<Plan> => {
      try {
        const fileContent = await fs.readFile(filePath, 'utf-8');
        const plan = yaml.load(fileContent) as Plan;
        return plan;
      } catch (error: any) {
        // Let the caller handle the error. They might want to know if it's a
        // file not found vs. a parsing error.
        throw error;
      }
    };
  src/commands/init.ts: |-
    import fs from 'fs/promises';
    import path from 'path';
    import chalk from 'chalk';
    import { EOL } from 'os';

    /**
     * @description Handles the logic for the 'init' command.
     */
    export const handleInitCommand = async (argv: {}): Promise<void> => {
      const rootDir = '.nocaflow';
      try {
        await fs.access(rootDir);
        console.warn(chalk.yellow(`Warning: '${rootDir}' directory already exists. Initialization skipped.`));
        process.exit(0);
      } catch (error) {
        // Directory does not exist, proceed.
      }

      const phases = ['initialization', 'development'];
      const planSubDirs = ['todo', 'doing', 'review', 'done', 'failed/report'];
      const agentLogDir = 'agent-log';

      const dirsToCreate: string[] = [];
      const gitkeepFiles: string[] = [];

      for (const phase of phases) {
        const phaseBase = path.join(rootDir, phase);
        const agentLogPath = path.join(phaseBase, agentLogDir);
        dirsToCreate.push(agentLogPath);
        gitkeepFiles.push(path.join(agentLogPath, '.gitkeep'));

        const plansBase = path.join(phaseBase, 'plans');
        for (const subDir of planSubDirs) {
          const dirPath = path.join(plansBase, subDir);
          dirsToCreate.push(dirPath);
          gitkeepFiles.push(path.join(dirPath, '.gitkeep'));
        }
      }

      try {
        await Promise.all(dirsToCreate.map(dir => fs.mkdir(dir, { recursive: true })));
        await Promise.all(gitkeepFiles.map(file => fs.writeFile(file, '')));

        console.log(chalk.green(' nocaflow project initialized successfully. ✨'));
        console.log(`Created ${chalk.bold(rootDir)} directory structure with ${dirsToCreate.length} directories and ${gitkeepFiles.length} .gitkeep files.`);
      } catch (error) {
        console.error(chalk.red('Failed to initialize nocaflow project:'), EOL, error);
        process.exit(1);
      }
    };
  src/commands/state.ts: >-
    import chalk from 'chalk';

    import { getPhaseStats, PhaseStats, getFailedReports, FailedReport } from
    '../utils/fs';

    import { getActiveAgents, AgentInfo } from '../utils/shell';

    import dayjs from 'dayjs';

    import relativeTime from 'dayjs/plugin/relativeTime';

    import { getRecentLogs, LogEntry } from '../utils/logs';

    import { getGitLog, GitCommit } from '../utils/git';


    dayjs.extend(relativeTime);


    /**
     * @description Renders a progress bar.
     * @param current - The current progress value.
     * @param total - The total value for 100%.
     * @param length - The character length of the bar.
     * @returns A string representing the progress bar.
     */
    export const renderProgressBar = (current: number, total: number, length:
    number = 20): string => {
      const percent = total > 0 ? current / total : 0;
      const filledLength = Math.round(length * percent);
      const emptyLength = length - filledLength;
      const filledBar = '▇'.repeat(filledLength);
      const emptyBar = '-'.repeat(emptyLength);
      const bar = `[${filledBar}${emptyBar}]`;
      const text = `(${current}/${total} plans done)`;

      return `${bar} ${text}`;
    };


    /**
     * @description Displays the full state report to the console.
     */
    export const handleStateCommand = async (argv: {}): Promise<void> => {
      const phaseStats: PhaseStats = await getPhaseStats();
      const activeAgents: AgentInfo[] = await getActiveAgents();
      const recentLogs: LogEntry[] = await getRecentLogs(5);
      const failedReports: FailedReport[] = await getFailedReports(24);
      const gitCommits: GitCommit[] = await getGitLog(10);
      const currentPhase = phaseStats.development?.total > 0 ? 'development' : 'initialization';

      // Header
      console.log(chalk.bold(`== nocaflow State [${dayjs().format('YYYY-MM-DD HH:mm:ss')}] ==`));
      console.log(`Current Phase: ${chalk.cyan(currentPhase)}`);
      
      // Phase Progress
      console.log(chalk.bold('\n== Phase Progress =='));
      for (const phaseName in phaseStats) {
        const stats = phaseStats[phaseName];
        const progressBar = renderProgressBar(stats.done, stats.total);
        console.log(`[${chalk.yellow(phaseName.toUpperCase())}]`.padEnd(18) + progressBar);
      }

      // Phase Stats
      console.log(chalk.bold('\n== Phase Stats (Plans) =='));
      for (const phaseName in phaseStats) {
        const stats = phaseStats[phaseName];
        if (stats.total === 0) continue;
        const statsString = `todo: ${stats.todo}, doing: ${stats.doing}, review: ${stats.review}, failed: ${stats.failed}, done: ${stats.done}`;
        console.log(`[${chalk.yellow(phaseName.toUpperCase())}]`.padEnd(18) + statsString);
      }

      // Active Agents
      console.log(chalk.bold('\n== Active Agents (tmux) =='));
      if (activeAgents.length === 0) {
        console.log('No active agents.');
      } else {
        for (const agent of activeAgents) {
          console.log(`[${chalk.blue(agent.phase)}|${chalk.magenta(agent.pid)}]`.padEnd(18) + `id:${agent.id} (running ${agent.runtime})`);
        }
      }

      // Recent Agent Activity
      console.log(chalk.bold('\n== Recent Agent Activity (last 5) =='));
      if (recentLogs.length === 0) {
        console.log('No recent activity.');
      } else {
        for (const log of recentLogs) {
          const statusColor = log.status === 'DONE' ? chalk.green : log.status === 'FAIL' ? chalk.red : chalk.gray;
          const time = dayjs(log.timestamp).fromNow();
          console.log(`${statusColor(`[${log.status}|${log.phase}|${log.agentId}]`)} plan:${log.planId} - ${log.message} (${chalk.gray(time)})`);
        }
      }

      // Stalled / Failed
      console.log(chalk.bold('\n== Stalled / Failed (last 24h) =='));
      if (failedReports.length === 0) {
        console.log('No failed reports in the last 24 hours.');
      } else {
        for (const report of failedReports) {
          console.log(`${chalk.red('[FAILED]')} plan:${report.planId} part:${report.partId} - "${report.reason}"`);
          console.log(`         Report: ${report.reportPath}`);
        }
      }

      // Recent Git Commits
      console.log(chalk.bold('\n== Recent Git Commits (all worktrees) =='));
      if (gitCommits.length === 0) {
        console.log('No recent commits.');
      } else {
        for (const commit of gitCommits) {
          const worktreeInfo = commit.worktree ? `(${chalk.cyan(commit.worktree)}) ` : '';
          console.log(`${chalk.yellow(commit.hash.slice(0, 7))} ${worktreeInfo}${commit.message}`);
        }
      }
    };
  package.json: |-
    {
      "name": "nocaflow",
      "version": "0.0.1",
      "description": "Filesystem-as-State for Phased LLM Swarms.",
      "main": "dist/index.js",
      "bin": {
        "nocaflow": "dist/cli.js"
      },
      "scripts": {
        "start": "node dist/cli.js",
        "build": "tsc",
        "dev": "ts-node src/cli.ts",
        "test": "jest",
        "lint": "eslint 'src/**/*.ts'"
      },
      "keywords": [
        "llm",
        "swarm",
        "agent",
        "orchestration"
      ],
      "author": "",
      "license": "ISC",
      "dependencies": {
        "chalk": "^4.1.2",
        "dayjs": "^1.11.10",
        "js-yaml": "^4.1.0",
        "yargs": "^17.7.2"
      },
      "devDependencies": {
        "@types/js-yaml": "^4.0.9",
        "@types/node": "^20.10.4",
        "@types/yargs": "^17.0.32",
        "@types/jest": "^29.5.11",
        "@typescript-eslint/eslint-plugin": "^6.14.0",
        "@typescript-eslint/parser": "^6.14.0",
        "eslint": "^8.55.0",
        "jest": "^29.7.0",
        "ts-jest": "^29.1.1",
        "ts-node": "^10.9.2",
        "typescript": "^5.3.3"
      }
    }
  src/utils/shell.ts: |-
    import { promisify } from 'util';
    import { exec as execCallback } from 'child_process';
    import dayjs from 'dayjs';
    import relativeTime from 'dayjs/plugin/relativeTime';
    import { Plan, PlanPart } from '../models/plan';

    export interface AgentInfo {
      phase: 'INIT' | 'DEV' | 'QA' | 'SCAF';
      id: string; // part_id, plan_id for QA/Scaffold
      planId: string;
      partId: string; // Can be 'scaffold' or 'qa'
      runtime: string;
      pid: string;
    }

    const exec = promisify(execCallback);
    dayjs.extend(relativeTime);

    /**
     * @description Lists active tmux sessions and parses them to find agent info.
     * @returns A list of active agents.
     */
    export const getActiveAgents = async (): Promise<AgentInfo[]> => {
      try {
        const { stdout } = await exec(`tmux ls -F "#{session_name} #{pane_pid} #{session_activity}"`);
        if (!stdout) return [];

        const lines = stdout.trim().split('\n');
        const agents: AgentInfo[] = [];

        for (const line of lines) {
          const [sessionName, pid, activity] = line.split(' ');
          const runtime = dayjs().to(dayjs.unix(parseInt(activity, 10)), true);

          let match;
          if ((match = sessionName.match(/^(init|dev)-(.+)/))) {
            const phase = match[1].toUpperCase() as 'INIT' | 'DEV';
            const partId = match[2];
            agents.push({
              phase,
              id: partId,
              planId: 'unknown', // Not available from session name
              partId: partId,
              runtime,
              pid,
            });
          } else if ((match = sessionName.match(/^init-scaffold-(.+)/))) {
            const planId = match[1];
            agents.push({
              phase: 'SCAF',
              id: planId,
              planId,
              partId: 'scaffold',
              runtime,
              pid,
            });
          } else if ((match = sessionName.match(/^qa-(.+)/))) {
            const planId = match[1];
            agents.push({ phase: 'QA', id: planId, planId, partId: 'qa', runtime, pid });
          }
        }
        return agents;
      } catch (error) {
        return []; // Tmux likely not running or has no sessions.
      }
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 24
