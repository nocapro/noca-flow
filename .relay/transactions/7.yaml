uuid: 4402660d-7cae-4f06-af53-485a06cc5988
projectId: noca-flow
createdAt: '2025-11-11T12:41:12.826Z'
gitCommitMsg: >-
  feat(blueprint): deepen alignment of cli commands and utils

  Refines the blueprints for all `TODO` blocks across the codebase to provide a
  more detailed "cheatsheet" for implementation agents.

  - Adds necessary imports, constants, and type definitions. - Provides
  commented-out logic snippets for core implementation flows in `init`, `state`,
  `fs`, `git`, `logs`, and `shell` modules. - Clarifies instructions to better
  align with agent protocols and the overall system design.
promptSummary: >-
  I need to deepen the alignment with agent protocols and lifecycle by creating
  more detailed blueprints in the codebase. I should add type signatures,
  important variables, and commented-out logic snippets to each file with a TODO
  block to serve as a "cheatsheet" for the next AI developer, without writing
  the full implementation.
reasoning:
  - >-
    This is a good next step. I'll deepen the alignment with the agent protocols
    by creating more detailed blueprints in the codebase. I will add type
    signatures, important variables, and commented-out logic snippets to each
    file with a `TODO` block. This will act as a "cheatsheet" for the next AI
    developer, guiding them to a successful implementation while still requiring
    them to write the actual code.
  - '### `init` command blueprint'
  - >-
    First, I'll flesh out the blueprint for the `init` command. This involves
    adding the necessary imports and defining the directory structure that needs
    to be created, providing a clear path for implementation.
  - '### `state` command blueprint'
  - >-
    Next, I'll update the `state` command. I'll add the `dayjs` import, provide
    a blueprint for the progress bar rendering, and lay out the sequence of data
    fetching and console output, preparing it for the implementation agent.
  - '### Filesystem utilities blueprint'
  - >-
    I will now refine all the filesystem utility functions. I'll provide
    blueprints for getting phase statistics, finding failed reports, and reading
    plan files, including commented-out logic for loops, file operations, and
    error handling.
  - '### Git utilities blueprint'
  - >-
    Here, I'll update the Git utility to provide a clearer structure for
    fetching and parsing the commit log across all worktrees.
  - '### Logs utilities blueprint'
  - >-
    The logging utility will get a blueprint for scanning log directories,
    parsing log entries with regex, and returning the most recent results.
  - '### Shell utilities blueprint'
  - >-
    Finally, I'll blueprint the shell utility for getting active agents. This
    involves adding the `dayjs` relative time plugin and laying out the logic
    for executing the `tmux` command and parsing its output.
  - '---'
operations:
  - type: write
    path: src/commands/init.ts
    content: >+
      --- src/commands/init.ts

      +++ src/commands/init.ts

      @@ -1,5 +1,6 @@
       import fs from 'fs/promises';
       import path from 'path';
      +import chalk from 'chalk';
       
       /**
        * @description Handles the logic for the 'init' command.
      @@ -15,5 +16,23 @@
         //    - e.g., '.nocaflow/initialization/agent-log/.gitkeep', '.nocaflow/development/plans/todo/.gitkeep', etc.
         // 5. Iterate through the `.gitkeep` file paths and create each empty file using `fs.writeFile(filePath, '')`.
         // 6. After successfully creating the structure, log a confirmation message to the console.
      +

      +  const rootDir = '.nocaflow';

      +  const phases = ['initialization', 'development'];

      +  const planDirs = ['todo', 'doing', 'review', 'done', 'failed/report'];

      +

      +  // Blueprint for directory structure

      +  const dirsToCreate: string[] = [];

      +  const gitkeepFiles: string[] = [];

      +

      +  // 1. Check for rootDir existence.

      +  // fs.access(rootDir).then(() => { console.warn(...) and
      process.exit(0) }).catch(() => { /* continue */ });

      +

      +  // 2 & 4. Loop phases and planDirs to populate dirsToCreate and
      gitkeepFiles.

      +  

      +  // 3 & 5. Loop through dirsToCreate/gitkeepFiles and call
      fs.mkdir/fs.writeFile.

      +

      +  // 6. Log success message using chalk.green.

      +
         throw new Error('Not implemented');
       };

    patchStrategy: standard-diff
  - type: write
    path: src/commands/state.ts
    content: >+
      --- src/commands/state.ts

      +++ src/commands/state.ts

      @@ -1,6 +1,7 @@
       import chalk from 'chalk';
       import { getPhaseStats, PhaseStats, getFailedReports, FailedReport } from '../utils/fs';
       import { getActiveAgents, AgentInfo } from '../utils/shell';
      +import dayjs from 'dayjs';
       import { getRecentLogs, LogEntry } from '../utils/logs';
       import { getGitLog, GitCommit } from '../utils/git';
       
      @@ -17,29 +18,63 @@
         // 3. Determine how many `length` characters should be empty (e.g., '-').
         // 4. Return a string like `[▇▇▇▇----] (current/total plans done)`.
         // 5. If total is 0, return a string representing an empty bar `[----------] (0/0 plans done)`.
      +

      +  // const percent = total > 0 ? current / total : 0;

      +  // const filledLength = Math.round(length * percent);

      +  // const emptyLength = length - filledLength;

      +  // const filledBar = '▇'.repeat(filledLength);

      +  // const emptyBar = '-'.repeat(emptyLength);

      +  // const bar = `[${filledBar}${emptyBar}]`;

      +  // const text = `(${current}/${total} plans done)`;

      +

      +  // return `${bar} ${text}`;

      +
         throw new Error('Not implemented');
       };
       
       /**
        * @description Displays the full state report to the console.
        */
       export const handleStateCommand = async (argv: {}): Promise<void> => {
         // TODO: part-state-fetch-data - Fetch all necessary data using utility functions.
         // INSTRUCTIONS:
      -  // 1. Determine the current phase. For now, this can be hardcoded or
      inferred. Assume 'initialization' then 'development'.
         // 2. Call `getPhaseStats()` to get statistics for all phases.
         // 3. Call `getActiveAgents()` to get a list of running agents.
         // 4. Call `getRecentLogs(5)` to get the last 5 log entries.
         // 5. Call `getFailedReports(24)` to get failures in the last 24 hours.
         // 6. Call `getGitLog(10)` to get the 10 most recent git commits.
      -  const phaseStats: PhaseStats = {} as PhaseStats;

      -  const activeAgents: AgentInfo[] = [];

      -  const recentLogs: LogEntry[] = [];

      -  const failedReports: FailedReport[] = [];

      -  const gitCommits: GitCommit[] = [];

      -  const currentPhase = 'initialization'; // Placeholder

      -  

      +

      +  // const phaseStats: PhaseStats = await getPhaseStats();

      +  // const activeAgents: AgentInfo[] = await getActiveAgents();

      +  // const recentLogs: LogEntry[] = await getRecentLogs(5);

      +  // const failedReports: FailedReport[] = await getFailedReports(24);

      +  // const gitCommits: GitCommit[] = await getGitLog(10);

      +  // const currentPhase = phaseStats.development?.total > 0 ?
      'development' : 'initialization';

      +
         // TODO: part-state-render-output - Format and print the state report.
         // INSTRUCTIONS:
         // 1. Use `chalk` for all coloring to match the style in the project's README.md.
      @@ -52,5 +87,46 @@
         // 7. Print recent agent activity from `recentLogs`, color-coding by status (DONE, FAIL).
         // 8. Print any stalled or failed reports from `failedReports`.
         // 9. Print recent git commits, including hash, worktree (if any), and message.
      +

      +  /*

      +  // Header

      +  console.log(chalk.bold(`== nocaflow State [${dayjs().format('YYYY-MM-DD
      HH:mm:ss')}] ==`));

      +  console.log(`Current Phase: ${chalk.cyan(currentPhase)}`);

      +  

      +  // Phase Progress

      +  console.log(chalk.bold('\n== Phase Progress =='));

      +  // for (const phaseName in phaseStats) { ... renderProgressBar(...) ...
      }

      +

      +  // Phase Stats

      +  console.log(chalk.bold('\n== Phase Stats (Plans) =='));

      +  // for (const phaseName in phaseStats) { ... console.log(...) ... }

      +

      +  // Active Agents

      +  console.log(chalk.bold('\n== Active Agents (tmux) =='));

      +  // if (activeAgents.length === 0) { console.log('No active agents.'); }

      +  // for (const agent of activeAgents) { ... console.log(...) ... }

      +

      +  // Recent Agent Activity

      +  console.log(chalk.bold('\n== Recent Agent Activity (last 5) =='));

      +  // if (recentLogs.length === 0) { console.log('No recent activity.'); }

      +  // for (const log of recentLogs) { ... console.log with color based on
      log.status ... }

      +

      +  // Stalled / Failed

      +  console.log(chalk.bold('\n== Stalled / Failed (last 24h) =='));

      +  // if (failedReports.length === 0) { console.log('No failed reports in
      the last 24 hours.'); }

      +  // for (const report of failedReports) { ... console.log(...) ... }

      +

      +  // Recent Git Commits

      +  console.log(chalk.bold('\n== Recent Git Commits (all worktrees) =='));

      +  // if (gitCommits.length === 0) { console.log('No recent commits.'); }

      +  // for (const commit of gitCommits) { ... console.log(...) ... }

      +  */

      +
         throw new Error('Not implemented');
       };

    patchStrategy: standard-diff
  - type: write
    path: src/utils/fs.ts
    content: >+
      --- src/utils/fs.ts

      +++ src/utils/fs.ts

      @@ -23,13 +23,35 @@
       export const getPhaseStats = async (): Promise<PhaseStats> => {
         // TODO: part-fs-get-phase-stats - Walk through .nocaflow/{phase}/plans/* directories and count plans.
         // INSTRUCTIONS:
      -  // 1. Define phase directories: ['.nocaflow/initialization',
      '.nocaflow/development'].

      -  // 2. For each phase, iterate through subdirectories: 'todo', 'doing',
      'review', 'failed', 'done'.

      +  // 1. Define phases: ['initialization', 'development'].

      +  // 2. Define statuses: ['todo', 'doing', 'review', 'failed', 'done'].
         // 3. Use `fs.readdir` to count the number of files in each subdirectory. Handle errors for non-existent directories (count should be 0).
         // 4. Aggregate the counts into a `PhaseStats` object.
         // 5. Calculate the `total` for each phase.
         // 6. Example structure for one phase:
         //    'initialization': { todo: 1, doing: 2, review: 1, failed: 0, done: 6, total: 10 }
         // 7. Return the final `PhaseStats` object.
      +

      +  // const phases = ['initialization', 'development'];

      +  // const statuses = ['todo', 'doing', 'review', 'failed', 'done'];

      +  // const stats: PhaseStats = {};

      +

      +  // for (const phase of phases) {

      +  //   stats[phase] = { todo: 0, doing: 0, review: 0, failed: 0, done: 0,
      total: 0 };

      +  //   for (const status of statuses) {

      +  //     const dirPath = path.join('.nocaflow', phase, 'plans', status);

      +  //     try {

      +  //       const files = await fs.readdir(dirPath);

      +  //       const count = files.filter(f => f.endsWith('.yml')).length;

      +  //       stats[phase][status as keyof typeof stats.phase] = count;

      +  //       stats[phase].total += count;

      +  //     } catch (error) {

      +  //       // Directory likely doesn't exist, count is 0.

      +  //     }

      +  //   }

      +  // }

      +  // return stats;

      +
         throw new Error('Not implemented');
       };
       
      @@ -41,7 +63,7 @@
       export const getFailedReports = async (hours: number): Promise<FailedReport[]> => {
         // TODO: part-fs-get-failed-reports - Scan failed report directories for recent failures.
         // INSTRUCTIONS:
      -  // 1. Define report directories to scan, e.g.,
      '.nocaflow/initialization/plans/failed/report'.

      +  // 1. Define phase directories to scan.
         // 2. Use `fs.readdir` to get all report files (ending in .md).
         // 3. For each file, get its stats using `fs.stat` to find the creation time (`birthtime`).
         // 4. Use `dayjs` to check if `birthtime` is within the last `hours`.
      @@ -50,6 +72,29 @@
         // 7. The filename typically follows the pattern `{planId}.{partId}.report.md`. Parse this to get IDs.
         // 8. Construct a `FailedReport` object and add it to a results array.
         // 9. Return the array of recent failed reports.
      +

      +  // const phases = ['initialization', 'development'];

      +  // const reports: FailedReport[] = [];

      +  // const since = dayjs().subtract(hours, 'hour');

      +

      +  // for (const phase of phases) {

      +  //   const reportDir = path.join('.nocaflow', phase, 'plans', 'failed',
      'report');

      +  //   try {

      +  //     const files = await fs.readdir(reportDir);

      +  //     for (const file of files) {

      +  //       if (!file.endsWith('.report.md')) continue;

      +  //       const filePath = path.join(reportDir, file);

      +  //       const stats = await fs.stat(filePath);

      +  //       if (dayjs(stats.birthtime).isAfter(since)) {

      +  //         // const content = await fs.readFile(filePath, 'utf-8');

      +  //         // const summaryMatch = content.match(/##
      Summary\s*\n\s*(.*)/);

      +  //         // const reason = summaryMatch ? summaryMatch[1].trim() :
      'Could not parse summary.';

      +  //         // const [planId, partId] = file.split('.').slice(0, 2);

      +  //         // reports.push({ planId, partId, reason, reportPath:
      filePath });

      +  //       }

      +  //     }

      +  //   } catch (error) { /* dir may not exist */ }

      +  // }

      +  // return reports;
         throw new Error('Not implemented');
       };
       
      @@ -61,9 +106,20 @@
       export const readPlan = async (filePath: string): Promise<Plan> => {
           // TODO: part-fs-read-plan - Read file content and parse using js-yaml.
           // INSTRUCTIONS:
      -    // 1. Use `fs.readFile` to read the content of `filePath` as a UTF-8
      string.

      +    // 1. Use `fs.readFile` to read the content of `filePath` as 'utf-8'.
           // 2. Use `yaml.load()` from the 'js-yaml' library to parse the string content.
           // 3. Cast the result to the `Plan` type and return it.
           // 4. Include error handling for file-not-found and YAML parsing errors.
      +

      +    // try {

      +    //   const fileContent = await fs.readFile(filePath, 'utf-8');

      +    //   const plan = yaml.load(fileContent) as Plan;

      +    //   return plan;

      +    // } catch (error) {

      +    //   // if (error.code === 'ENOENT') { ... }

      +    //   // else if (error instanceof YAMLException) { ... }

      +    //   // else { ... }

      +    //   throw error;

      +    // }
           throw new Error('Not implemented');
       };

    patchStrategy: standard-diff
  - type: write
    path: src/utils/git.ts
    content: >+
      --- src/utils/git.ts

      +++ src/utils/git.ts

      @@ -17,16 +17,32 @@
       export const getGitLog = async (limit: number): Promise<GitCommit[]> => {
         // TODO: part-git-get-log - Get recent git commits across all worktrees.
         // INSTRUCTIONS:
      -  // 1. First, get a map of worktree paths to their names. Execute `git
      worktree list --porcelain`.

      -  //    Parse the output to create a map like: {
      '/path/to/worktrees/wt-name': 'wt-name' }.

      -  // 2. Execute `git log --all -n ${limit} --pretty=format:'%H|%s|%D'`.
      The `%D` ref names can help identify worktrees.

      -  //    The output for each commit will be like: `a4e2c1f|feat: some
      message|HEAD -> main, origin/main, worktrees/wt-dev-995104/HEAD`

      -  // 3. Split the log output by newline to process each commit.

      -  // 4. For each line, split by '|' to get hash, message, and ref names.

      -  // 5. In the ref names string, look for a worktree path (e.g.,
      'worktrees/wt-dev-995104'). Match this against the map from step 1 to find
      the worktree name.

      -  // 6. If no worktree is found, the `worktree` property should be
      `null`.

      -  // 7. Construct `GitCommit` objects and return them in an array.

      +  // 1. Execute `git worktree list --porcelain` to get worktree info.

      +  //    - Parse the output to create a map: { 'worktrees/wt-name':
      'wt-name' }.

      +  // 2. Execute `git log --all -n ${limit} --pretty=format:'%H|%s|%D'`.

      +  // 3. Process the log output line by line.

      +  // 4. For each line, parse hash, message, and refs.

      +  // 5. Match refs against the worktree map to find the worktree name.

      +  // 6. Create `GitCommit` objects and add to a results array.

      +

      +  // const getWorktreeMap = async (): Promise<Map<string, string>> => {

      +  //   // const { stdout } = await exec('git worktree list --porcelain');

      +  //   // const map = new Map<string, string>();

      +  //   // parse stdout and populate map, e.g. extract 'worktrees/wt-...'
      and the final part as the name.

      +  //   // return map;

      +  // }

      +

      +  // try {

      +  //   // const worktreeMap = await getWorktreeMap();

      +  //   // const { stdout: logOutput } = await exec(`...`);

      +  //   // const commits: GitCommit[] =
      logOutput.trim().split('\n').map(line => {

      +  //   //   // ... parse line ...

      +  //   //   // ... find worktree from refs using worktreeMap ...

      +  //   //   // return { hash, message, worktree };

      +  //   // });

      +  //   // return commits;

      +  // } catch (error) {

      +  //   return []; // Git not installed or not a git repo.

      +  // }
         throw new Error('Not implemented');
       };

    patchStrategy: standard-diff
  - type: write
    path: src/utils/logs.ts
    content: >+
      --- src/utils/logs.ts

      +++ src/utils/logs.ts

      @@ -19,16 +19,37 @@
       export const getRecentLogs = async (limit: number): Promise<LogEntry[]> => {
         // TODO: part-logs-get-recent - Read and parse agent log files.
         // INSTRUCTIONS:
      -  // 1. Define log directories to scan:
      ['.nocaflow/initialization/agent-log', '.nocaflow/development/agent-log'].

      -  // 2. Recursively find all files ending in `.log` within these
      directories.

      -  // 3. Read the content of each log file. Each line is a potential log
      entry.

      -  // 4. For each line, use a regex to parse it. A good starting regex is:

      +  // 1. Define phase directories to scan.

      +  // 2. Find all `.log` files in the `agent-log` subdirectories.

      +  // 3. Read content of each log file.

      +  // 4. For each line, use regex to parse. Example:
         //    /^(?<timestamp>.*?) \[(?<status>\w+)\|(?<phase>\w+)\|(?<agentId>.*?)\] plan:(?<planId>\S+) - (?<message>.*)$/
      -  // 5. If a line matches, create a `LogEntry` object. Convert the
      timestamp string to a `Date` object.

      -  // 6. Collect all parsed log entries into a single array.

      -  // 7. Sort the array in descending order by timestamp (newest first).

      +  // 5. Create `LogEntry` objects from matches. Convert timestamp string
      to a `Date`.

      +  // 6. Collect all entries.

      +  // 7. Sort entries by timestamp (descending).
         // 8. Return a slice of the array containing the top `limit` entries.
      +

      +  // const logDirs = ['.nocaflow/initialization/agent-log',
      '.nocaflow/development/agent-log'];

      +  // let allEntries: LogEntry[] = [];

      +  // const logRegex = /^(?<timestamp>.*?)
      \[(?<status>\w+)\|(?<phase>\w+)\|(?<agentId>.*?)\] plan:(?<planId>\S+) -
      (?<message>.*)$/;

      +

      +  // for (const dir of logDirs) {

      +  //   try {

      +  //     const files = await fs.readdir(dir);

      +  //     for (const file of files.filter(f => f.endsWith('.log'))) {

      +  //       // const content = await fs.readFile(path.join(dir, file),
      'utf-8');

      +  //       // for (const line of content.split('\n')) {

      +  //       //   const match = line.match(logRegex);

      +  //       //   if (match?.groups) {

      +  //       //     // create LogEntry and push to allEntries

      +  //       //   }

      +  //       // }

      +  //     }

      +  //   } catch (error) { /* dir may not exist */ }

      +  // }

      +

      +  // allEntries.sort((a, b) => b.timestamp.getTime() -
      a.timestamp.getTime());

      +  // return allEntries.slice(0, limit);

      +
         throw new Error('Not implemented');
       };

    patchStrategy: standard-diff
  - type: write
    path: src/utils/shell.ts
    content: >+
      --- src/utils/shell.ts

      +++ src/utils/shell.ts

      @@ -1,6 +1,7 @@
       import { promisify } from 'util';
       import { exec as execCallback } from 'child_process';
       import dayjs from 'dayjs';
      +import relativeTime from 'dayjs/plugin/relativeTime';
       import { Plan, PlanPart } from '../models/plan';
       
       export interface AgentInfo {
      @@ -13,6 +14,7 @@
       }
       
       const exec = promisify(execCallback);
      +dayjs.extend(relativeTime);
       
       /**
        * @description Lists active tmux sessions and parses them to find agent info.
      @@ -21,17 +23,38 @@
       export const getActiveAgents = async (): Promise<AgentInfo[]> => {
         // TODO: part-shell-get-agents - List and parse active tmux sessions to find agent info.
         // INSTRUCTIONS:
      -  // 1. Execute `tmux ls -F "#{session_name} #{pane_pid}
      #{session_activity}"`. Use `promisify(exec)`.

      -  // 2. Split the stdout by newline to get a list of active sessions.

      -  // 3. For each session string, parse it to extract name, PID, and
      activity timestamp.

      -  // 4. Use regex or string splitting on the session name to determine
      the agent type and IDs based on conventions from `manager.agent.md`:

      +  // 1. Execute `tmux ls -F "#{session_name} #{pane_pid}
      #{session_activity}"`.

      +  // 2. Handle errors (e.g., tmux not running). Return empty array on
      failure.

      +  // 3. Parse each line of stdout.

      +  // 4. Use regex on session name to determine agent type and extract
      IDs.
         //    - Worker: /^(init|dev)-(.+)/ -> { phase, partId }
         //    - Scaffolder: /^(init)-scaffold-(.+)/ -> { phase: 'SCAF', planId }
         //    - QA: /^qa-(.+)/ -> { phase: 'QA', planId }
      -  // 5. For worker agents, you need to find the planId. This is tricky. A
      simplified approach is to assume the `partId` is unique and not try to
      look up the plan file. The `planId` can be set to 'unknown' or the partId.
      A better approach would be to scan `doing` directories for plans
      containing the partId. Let's stick to the simpler one for now.

      -  // 6. Calculate runtime: The `session_activity` is a Unix timestamp.
      Use `dayjs` to find the duration from that time to now (e.g.,
      `dayjs().to(dayjs.unix(timestamp))`).

      -  // 7. Construct `AgentInfo` objects for each valid session.

      -  // 8. Return the list of `AgentInfo` objects.

      -  // 9. Handle the case where tmux is not running or there are no
      sessions (command might fail or return empty string).

      +  // 5. For worker agents, `planId` can be 'unknown' for this
      implementation.

      +  // 6. Calculate runtime from `session_activity` Unix timestamp using
      `dayjs().to(dayjs.unix(timestamp), true)`.

      +  // 7. Construct and return an array of `AgentInfo` objects.

      +

      +  // try {

      +  //   const { stdout } = await exec(`tmux ls -F "#{session_name}
      #{pane_pid} #{session_activity}"`);

      +  //   if (!stdout) return [];

      +  //

      +  //   const lines = stdout.trim().split('\n');

      +  //   const agents: AgentInfo[] = [];

      +  //

      +  //   for (const line of lines) {

      +  //     const [sessionName, pid, activity] = line.split(' ');

      +  //     const runtime = dayjs().to(dayjs.unix(parseInt(activity, 10)),
      true);

      +  //

      +  //     let match;

      +  //     // if ((match = sessionName.match(/^(init|dev)-(.+)/))) { ... }

      +  //     // else if ((match = sessionName.match(/^init-scaffold-(.+)/)))
      { ... }

      +  //     // else if ((match = sessionName.match(/^qa-(.+)/))) { ... }

      +  //     //

      +  //     // In each block, construct an AgentInfo object and push to
      agents array.

      +  //   }

      +  //   return agents;

      +  // } catch (error) {

      +  //   return []; // Tmux likely not running or has no sessions.

      +  // }
         throw new Error('Not implemented');
       };

    patchStrategy: standard-diff
snapshot:
  src/commands/init.ts: |-
    import fs from 'fs/promises';
    import path from 'path';

    /**
     * @description Handles the logic for the 'init' command.
     */
    export const handleInitCommand = async (argv: {}): Promise<void> => {
      // TODO: part-init-scaffold - Create the initial .nocaflow directory structure.
      // INSTRUCTIONS:
      // 1. Check if a `.nocaflow` directory already exists in the current working directory. If it does, log a warning message and exit the process to avoid overwriting existing state.
      // 2. Define an array of directory paths that need to be created. This should include all subdirectories for both 'initialization' and 'development' phases as seen in the project structure.
      //    - e.g., '.nocaflow/initialization/agent-log', '.nocaflow/initialization/plans/todo', etc.
      // 3. Iterate through the array and use `fs.mkdir` with the `{ recursive: true }` option to create each directory.
      // 4. Define an array of paths for `.gitkeep` files that should be placed in empty directories to ensure they are tracked by Git.
      //    - e.g., '.nocaflow/initialization/agent-log/.gitkeep', '.nocaflow/development/plans/todo/.gitkeep', etc.
      // 5. Iterate through the `.gitkeep` file paths and create each empty file using `fs.writeFile(filePath, '')`.
      // 6. After successfully creating the structure, log a confirmation message to the console.
      throw new Error('Not implemented');
    };
  src/commands/state.ts: >-
    import chalk from 'chalk';

    import { getPhaseStats, PhaseStats, getFailedReports, FailedReport } from
    '../utils/fs';

    import { getActiveAgents, AgentInfo } from '../utils/shell';

    import { getRecentLogs, LogEntry } from '../utils/logs';

    import { getGitLog, GitCommit } from '../utils/git';


    /**
     * @description Renders a progress bar.
     * @param current - The current progress value.
     * @param total - The total value for 100%.
     * @param length - The character length of the bar.
     * @returns A string representing the progress bar.
     */
    const renderProgressBar = (current: number, total: number, length: number =
    20): string => {
      // TODO: part-state-render-progress - Implement progress bar rendering logic.
      // INSTRUCTIONS:
      // 1. Calculate the percentage of `current` to `total`.
      // 2. Determine how many `length` characters should be filled (e.g., '▇').
      // 3. Determine how many `length` characters should be empty (e.g., '-').
      // 4. Return a string like `[▇▇▇▇----] (current/total plans done)`.
      // 5. If total is 0, return a string representing an empty bar `[----------] (0/0 plans done)`.
      throw new Error('Not implemented');
    };


    /**
     * @description Displays the full state report to the console.
     */
    export const handleStateCommand = async (argv: {}): Promise<void> => {
      // TODO: part-state-fetch-data - Fetch all necessary data using utility functions.
      // INSTRUCTIONS:
      // 1. Determine the current phase. For now, this can be hardcoded or inferred. Assume 'initialization' then 'development'.
      // 2. Call `getPhaseStats()` to get statistics for all phases.
      // 3. Call `getActiveAgents()` to get a list of running agents.
      // 4. Call `getRecentLogs(5)` to get the last 5 log entries.
      // 5. Call `getFailedReports(24)` to get failures in the last 24 hours.
      // 6. Call `getGitLog(10)` to get the 10 most recent git commits.
      const phaseStats: PhaseStats = {} as PhaseStats;
      const activeAgents: AgentInfo[] = [];
      const recentLogs: LogEntry[] = [];
      const failedReports: FailedReport[] = [];
      const gitCommits: GitCommit[] = [];
      const currentPhase = 'initialization'; // Placeholder
      
      // TODO: part-state-render-output - Format and print the state report.
      // INSTRUCTIONS:
      // 1. Use `chalk` for all coloring to match the style in the project's README.md.
      // 2. Print a header with the current time.
      // 3. Print the current phase.
      // 4. Print phase progress using `renderProgressBar` for each phase found in `phaseStats`.
      // 5. Print detailed plan counts for each phase.
      // 6. Print a list of active agents, including their phase, IDs, and runtime.
      // 7. Print recent agent activity from `recentLogs`, color-coding by status (DONE, FAIL).
      // 8. Print any stalled or failed reports from `failedReports`.
      // 9. Print recent git commits, including hash, worktree (if any), and message.
      throw new Error('Not implemented');
    };
  src/utils/fs.ts: >-
    import path from 'path';

    import fs from 'fs/promises';

    import yaml from 'js-yaml';

    import dayjs from 'dayjs';

    import { Plan } from '../models/plan';


    export interface PhaseStats {
      [phaseName: string]: {
        todo: number;
        doing: number;
        review: number;
        failed: number;
        done: number;
        total: number;
      };
    }


    export interface FailedReport {
      planId: string;
      partId: string;
      reason: string;
      reportPath: string;
    }


    /**
     * @description Reads all plan files from all phases and aggregates stats.
     * @returns An object containing plan counts for each status in each phase.
     */
    export const getPhaseStats = async (): Promise<PhaseStats> => {
      // TODO: part-fs-get-phase-stats - Walk through .nocaflow/{phase}/plans/* directories and count plans.
      // INSTRUCTIONS:
      // 1. Define phase directories: ['.nocaflow/initialization', '.nocaflow/development'].
      // 2. For each phase, iterate through subdirectories: 'todo', 'doing', 'review', 'failed', 'done'.
      // 3. Use `fs.readdir` to count the number of files in each subdirectory. Handle errors for non-existent directories (count should be 0).
      // 4. Aggregate the counts into a `PhaseStats` object.
      // 5. Calculate the `total` for each phase.
      // 6. Example structure for one phase:
      //    'initialization': { todo: 1, doing: 2, review: 1, failed: 0, done: 6, total: 10 }
      // 7. Return the final `PhaseStats` object.
      throw new Error('Not implemented');
    };


    /**
     * @description Scans the failed reports directory for recent failures.
     * @param hours - The lookback period in hours.
     * @returns A list of failed report details.
     */
    export const getFailedReports = async (hours: number):
    Promise<FailedReport[]> => {
      // TODO: part-fs-get-failed-reports - Scan failed report directories for recent failures.
      // INSTRUCTIONS:
      // 1. Define report directories to scan, e.g., '.nocaflow/initialization/plans/failed/report'.
      // 2. Use `fs.readdir` to get all report files (ending in .md).
      // 3. For each file, get its stats using `fs.stat` to find the creation time (`birthtime`).
      // 4. Use `dayjs` to check if `birthtime` is within the last `hours`.
      // 5. If it is recent, read the file content.
      // 6. Parse the markdown content to extract the summary/reason. A simple regex or string search for a "Summary" section is sufficient.
      // 7. The filename typically follows the pattern `{planId}.{partId}.report.md`. Parse this to get IDs.
      // 8. Construct a `FailedReport` object and add it to a results array.
      // 9. Return the array of recent failed reports.
      throw new Error('Not implemented');
    };


    /**
     * @description Reads and parses a YAML plan file.
     * @param filePath - The path to the plan.yml file.
     * @returns The parsed Plan object.
     */
    export const readPlan = async (filePath: string): Promise<Plan> => {
        // TODO: part-fs-read-plan - Read file content and parse using js-yaml.
        // INSTRUCTIONS:
        // 1. Use `fs.readFile` to read the content of `filePath` as a UTF-8 string.
        // 2. Use `yaml.load()` from the 'js-yaml' library to parse the string content.
        // 3. Cast the result to the `Plan` type and return it.
        // 4. Include error handling for file-not-found and YAML parsing errors.
        throw new Error('Not implemented');
    };
  src/utils/git.ts: |-
    import { promisify } from 'util';
    import { exec as execCallback } from 'child_process';

    export interface GitCommit {
      hash: string;
      worktree: string | null;
      message: string;
    }

    const exec = promisify(execCallback);

    /**
     * @description Executes 'git log' to get recent commit history across all worktrees.
     * @param limit - The maximum number of commits to return.
     * @returns A list of recent git commits.
     */
    export const getGitLog = async (limit: number): Promise<GitCommit[]> => {
      // TODO: part-git-get-log - Get recent git commits across all worktrees.
      // INSTRUCTIONS:
      // 1. First, get a map of worktree paths to their names. Execute `git worktree list --porcelain`.
      //    Parse the output to create a map like: { '/path/to/worktrees/wt-name': 'wt-name' }.
      // 2. Execute `git log --all -n ${limit} --pretty=format:'%H|%s|%D'`. The `%D` ref names can help identify worktrees.
      //    The output for each commit will be like: `a4e2c1f|feat: some message|HEAD -> main, origin/main, worktrees/wt-dev-995104/HEAD`
      // 3. Split the log output by newline to process each commit.
      // 4. For each line, split by '|' to get hash, message, and ref names.
      // 5. In the ref names string, look for a worktree path (e.g., 'worktrees/wt-dev-995104'). Match this against the map from step 1 to find the worktree name.
      // 6. If no worktree is found, the `worktree` property should be `null`.
      // 7. Construct `GitCommit` objects and return them in an array.
      throw new Error('Not implemented');
    };
  src/utils/logs.ts: |-
    import path from 'path';
    import fs from 'fs/promises';

     export interface LogEntry {
      status: 'DONE' | 'FAIL' | 'INFO';
      phase: 'INIT' | 'DEV' | 'QA';
      agentId: string;
      planId: string;
      message: string;
      timestamp: Date;
    }

    /**
     * @description Reads the agent log files and returns the most recent entries.
     * @param limit - The maximum number of log entries to return.
     * @returns A list of recent log entries, sorted newest first.
     */
    export const getRecentLogs = async (limit: number): Promise<LogEntry[]> => {
      // TODO: part-logs-get-recent - Read and parse agent log files.
      // INSTRUCTIONS:
      // 1. Define log directories to scan: ['.nocaflow/initialization/agent-log', '.nocaflow/development/agent-log'].
      // 2. Recursively find all files ending in `.log` within these directories.
      // 3. Read the content of each log file. Each line is a potential log entry.
      // 4. For each line, use a regex to parse it. A good starting regex is:
      //    /^(?<timestamp>.*?) \[(?<status>\w+)\|(?<phase>\w+)\|(?<agentId>.*?)\] plan:(?<planId>\S+) - (?<message>.*)$/
      // 5. If a line matches, create a `LogEntry` object. Convert the timestamp string to a `Date` object.
      // 6. Collect all parsed log entries into a single array.
      // 7. Sort the array in descending order by timestamp (newest first).
      // 8. Return a slice of the array containing the top `limit` entries.
      throw new Error('Not implemented');
    };
  src/utils/shell.ts: |-
    import { promisify } from 'util';
    import { exec as execCallback } from 'child_process';
    import dayjs from 'dayjs';
    import { Plan, PlanPart } from '../models/plan';

    export interface AgentInfo {
      phase: 'INIT' | 'DEV' | 'QA' | 'SCAF';
      id: string; // part_id, plan_id for QA/Scaffold
      planId: string;
      partId: string; // Can be 'scaffold' or 'qa'
      runtime: string;
      pid: string;
    }

    const exec = promisify(execCallback);

    /**
     * @description Lists active tmux sessions and parses them to find agent info.
     * @returns A list of active agents.
     */
    export const getActiveAgents = async (): Promise<AgentInfo[]> => {
      // TODO: part-shell-get-agents - List and parse active tmux sessions to find agent info.
      // INSTRUCTIONS:
      // 1. Execute `tmux ls -F "#{session_name} #{pane_pid} #{session_activity}"`. Use `promisify(exec)`.
      // 2. Split the stdout by newline to get a list of active sessions.
      // 3. For each session string, parse it to extract name, PID, and activity timestamp.
      // 4. Use regex or string splitting on the session name to determine the agent type and IDs based on conventions from `manager.agent.md`:
      //    - Worker: /^(init|dev)-(.+)/ -> { phase, partId }
      //    - Scaffolder: /^(init)-scaffold-(.+)/ -> { phase: 'SCAF', planId }
      //    - QA: /^qa-(.+)/ -> { phase: 'QA', planId }
      // 5. For worker agents, you need to find the planId. This is tricky. A simplified approach is to assume the `partId` is unique and not try to look up the plan file. The `planId` can be set to 'unknown' or the partId. A better approach would be to scan `doing` directories for plans containing the partId. Let's stick to the simpler one for now.
      // 6. Calculate runtime: The `session_activity` is a Unix timestamp. Use `dayjs` to find the duration from that time to now (e.g., `dayjs().to(dayjs.unix(timestamp))`).
      // 7. Construct `AgentInfo` objects for each valid session.
      // 8. Return the list of `AgentInfo` objects.
      // 9. Handle the case where tmux is not running or there are no sessions (command might fail or return empty string).
      throw new Error('Not implemented');
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 7
