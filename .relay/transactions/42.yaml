uuid: f19c4d9b-a7e8-4b2a-89f5-1d37b67b1b34
projectId: noca-flow
createdAt: '2025-11-13T03:21:41.960Z'
gitCommitMsg: >-
  test(e2e): add comprehensive e2e test for state command

  Replaces the previous placeholder "complex state" test with a robust
  end-to-end validation for the `nocaflow state` command.

  This new test orchestrates a realistic project scenario by: - Initializing a
  nocaflow project and git repository. - Creating dummy plan files across
  multiple phases and statuses. - Generating a failed report and a sample agent
  log file. - Spawning a live `tmux` session to simulate an active agent.

  It then runs the `state` command and asserts that the output correctly
  reflects all created artifacts, including phase progress, active agents,
  recent logs, failed reports, and git history. The test is designed to be
  idempotent and cleans up the `tmux` session, ensuring a reliable CI run.
promptSummary: >-
  The user requested to execute Part 4 of the plan, which involves creating a
  comprehensive end-to-end test for the `nocaflow state` command to validate its
  full observability features.
reasoning:
  - >-
    Alright, Part 4. Locking down the `state` command with a full E2E test. No
    more blind spots. We're going to simulate an active, slightly chaotic
    project and ensure the dashboard reports every detail with 100% accuracy.
    This is the final guardrail.
  - >-
    Here's the patch for `test/e2e/cli.test.ts`. I'm replacing the existing,
    incomplete "complex state" test with a comprehensive one that validates
    every new data source: `tmux` for live agents, filesystem logs, failure
    reports, and git history. It's built to run with a live `tmux` server but
    will gracefully skip the agent check if `tmux` isn't available.
  - '---'
operations:
  - type: write
    path: test/e2e/cli.test.ts
    content: >
      --- test/e2e/cli.test.ts

      +++ test/e2e/cli.test.ts

      @@ -3,6 +3,7 @@
       import { exec as execCallback } from 'child_process';
       import path from 'path';
       import { promisify } from 'util';
      +import { platform } from '../src/utils/platform';
       
       const promisedExec = promisify(execCallback);
       
      @@ -52,22 +53,49 @@
             expect(code).toBe(0);
           });
       
      -    it('should display a complex state with active agents and failed
      reports', async () => {

      +    it('should display a complex, multi-faceted state correctly', async
      () => {
             await runCli('init');
             await initGitRepo();
      +

      +      // Setup: Create various artifacts
             await createDummyPlanFile('initialization', 'doing', 'p1.yml');
             await createDummyPlanFile('development', 'done', 'p2.yml');
             await createDummyFailedReport('initialization', 'f01', 'pA', 'Test failure');
       
      -      const { stdout, code } = await runCli('state');

      +      const logDir = '.nocaflow/development/agent-log';

      +      await fs.mkdir(logDir, { recursive: true });

      +      const logContent = `2023-10-27T10:00:00.000Z [DONE|DEV|agent-abc]
      plan:plan-e2e - Log message`;

      +      await fs.writeFile(path.join(logDir, 'test.log'), logContent);

      +

      +      const tmuxSessionName = 'dev-e2e-part-xyz';

      +      const canRunTmux = await platform.commandExists('tmux');

      +      if (canRunTmux) {

      +        await platform.runCommand(`tmux new-session -d -s
      ${tmuxSessionName} "sleep 15"`);

      +      }

      +

      +      // Act: Run the state command

      +      let stdout: string, code: number;

      +      try {

      +        const result = await runCli('state');

      +        stdout = result.stdout;

      +        code = result.code;

      +      } finally {

      +        // Teardown: ensure tmux session is killed

      +        if (canRunTmux) {

      +          await platform.runCommand(`tmux kill-session -t
      ${tmuxSessionName} || true`);

      +        }

      +      }
       
             expect(code).toBe(0);
      -      expect(stdout).toContain('Active Agents (tmux)');

      -      expect(stdout).toContain('Stalled / Failed');

      +      // Assert on all sections

      +      expect(stdout).toContain('Current Phase: development');

      +      expect(stdout).toContain('[INITIALIZATION]'.padEnd(18) +
      '[----------] (0/1 plans done)');

      +      expect(stdout).toContain('[DEVELOPMENT]'.padEnd(18) + '[▇▇▇▇▇▇▇▇▇▇]
      (1/1 plans done)');

      +      if (canRunTmux) {

      +        expect(stdout).toContain('id:e2e-part-xyz');

      +      }

      +      expect(stdout).toContain('plan:plan-e2e - Log message');
             expect(stdout).toContain('plan:f01 part:pA - "Test failure"');
      -      expect(stdout).toContain('Recent Git Commits');
             expect(stdout).toContain('Initial commit');
           });
       
    patchStrategy: standard-diff
snapshot:
  test/e2e/cli.test.ts: >-
    import { runCli, setupTestDirectory, createDummyPlanFile,
    createDummyFailedReport, initGitRepo } from '../test.util';

    import fs from 'fs/promises';

    import { exec as execCallback } from 'child_process';

    import path from 'path';

    import { promisify } from 'util';


    const promisedExec = promisify(execCallback);



    describe('e2e/cli', () => {
      let cleanup: () => Promise<void>;
      let testDir: string;

      beforeAll(async () => {
        try {
          await promisedExec('npm run build');
        } catch (e) {
          console.error('Failed to build project for E2E tests:', e);
          process.exit(1);
        }
      }, 60000);

      beforeEach(async () => {
        const { cleanup: c, testDir: td } = await setupTestDirectory();
        cleanup = c;
        testDir = td;
      });

      afterEach(async () => {
        if (cleanup) {
          await cleanup();
        }
      });

      describe('init command', () => {
        it('should initialize a new project structure', async () => {
          const { stdout, code } = await runCli('init');

          expect(stdout).toContain('nocaflow project initialized successfully');
          expect(code).toBe(0);

          const expectedFile = path.join(testDir, '.nocaflow/initialization/plans/todo/.gitkeep');
          await expect(fs.access(expectedFile)).resolves.toBeUndefined();
        });

        it('should show a warning if the project is already initialized', async () => {
          await fs.mkdir('.nocaflow'); // Manually create the directory
          const { stderr, code } = await runCli('init');

          expect(stderr).toContain("Warning: '.nocaflow' directory already exists. Initialization skipped.");
          expect(code).toBe(0); // Graceful exit on warning
        });
      });

      describe('state command', () => {
        it('should display the project state in an initialized directory', async () => {
          await runCli('init');
          await createDummyPlanFile('initialization', 'todo', 'plan1.yml');

          const { stdout, code } = await runCli('state');

          expect(stdout).toContain('== nocaflow State');
          expect(stdout).toContain('Phase Progress');
          expect(stdout).toContain('Current Phase: initialization');
          expect(stdout).toContain('todo: 1');
          expect(code).toBe(0);
        });

        it('should display a complex state with active agents and failed reports', async () => {
          await runCli('init');
          await initGitRepo();
          await createDummyPlanFile('initialization', 'doing', 'p1.yml');
          await createDummyPlanFile('development', 'done', 'p2.yml');
          await createDummyFailedReport('initialization', 'f01', 'pA', 'Test failure');

          const { stdout, code } = await runCli('state');

          expect(code).toBe(0);
          expect(stdout).toContain('Active Agents (tmux)');
          expect(stdout).toContain('Stalled / Failed');
          expect(stdout).toContain('plan:f01 part:pA - "Test failure"');
          expect(stdout).toContain('Recent Git Commits');
          expect(stdout).toContain('Initial commit');
        });

        it('should show a zero-state when run in a non-initialized directory', async () => {
          const { stdout, stderr, code } = await runCli('state');
          
          expect(stderr).toBe('');
          expect(code).toBe(0);
          expect(stdout).toContain('Current Phase: initialization');
          expect(stdout).toContain('(0/0 plans done)');
          expect(stdout).toContain('No active agents.');
          expect(stdout).toContain('No recent activity.');
          expect(stdout).toContain('No failed reports in the last 24 hours.');
        });
      });

      describe('no command', () => {
        it('should display help when no command is provided', async () => {
          const { stderr } = await runCli('');
          expect(stderr).toContain('Commands:');
          expect(stderr).toContain('init');
          expect(stderr).toContain('state');
          expect(stderr).toContain('You need at least one command before moving on');
        });

        it('should display help when --help flag is used', async () => {
          const generalHelp = await runCli('--help');
          expect(generalHelp.stdout).toContain('Show help');

          const stateHelp = await runCli('state --help');
          expect(stateHelp.stdout).toContain('Display the current state of the nocaflow project');
        });

        it('should show an error for an unknown command', async () => {
          const { stderr } = await runCli('nonexistent-command');
          expect(stderr).toContain('Unknown argument: nonexistent-command');
        });
      });
    });
approved: true
linesAdded: 35
linesRemoved: 5
linesDifference: 40
gitCommittedAt: '2025-11-13T03:26:13.610Z'
status: committed
id: 42
