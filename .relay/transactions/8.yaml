uuid: d89d1b06-a246-4d2d-8ca3-31649666014e
projectId: noca-flow
createdAt: '2025-11-11T12:47:25.887Z'
gitCommitMsg: >-
  feat(testing): blueprint comprehensive test suite

  This commit establishes the foundation for a robust testing strategy by
  blueprinting a full suite of unit, integration, and end-to-end tests.

  - Restructures all tests to live under a centralized `test/` directory. -
  Updates Jest configuration (`jest.config.js`) to target the new test directory
  structure. - Decommissions the old, separate `unit/`, `integration/`, and
  `e2e/` directories. - Creates detailed "cheatsheet" test files for all
  commands and utilities, outlining specific test cases with TODO comments. -
  Exports a helper function from `state.ts` to make it unit-testable.
promptSummary: >-
  The user requested to blueprint test cases for the nocaflow project. This
  includes creating a new `test/` directory structure, adding placeholder test
  files with TODOs, updating the jest config, and making a small code change to
  improve testability.
reasoning:
  - >-
    This plan outlines the creation of a comprehensive test suite for the
    `nocaflow` CLI application. I will restructure the testing directories to
    centralize all tests under a new `test/` directory, broken down into `unit`,
    `integration`, and `e2e` subdirectories. This improves organization and
    aligns with common testing practices.
  - >-
    First, I will update the Jest configuration to recognize the new test
    directory structure. Then, I will remove the old, now-empty test
    directories.
  - >-
    Next, I will blueprint the test files. For each area of the
    application—commands, filesystem utilities, Git interactions, etc.—I will
    create a corresponding test file. These blueprints will contain the
    necessary imports, `describe` and `it` blocks, and `TODO` comments that
    detail the specific test cases to be implemented. This "cheatsheet" approach
    will guide the next AI developer in writing the actual test logic.
  - >-
    Finally, I'll make a minor modification to `src/commands/state.ts` to export
    a helper function, `renderProgressBar`, making it accessible for unit
    testing.
  - '### 1. Configure Jest for New Test Structure'
  - >-
    I'll start by updating `jest.config.js` to point to the new `test/`
    directory, ensuring that the test runner can find and execute the new test
    suite.
  - '### 2. Decommission Old Test Directories'
  - >-
    I will delete the placeholder `.gitkeep` files from the old `unit/`,
    `integration/`, and `e2e/` directories. This effectively removes them from
    version control, cleaning up the project structure.
  - '### 3. Enable Testability of `state` command'
  - >-
    I will export the `renderProgressBar` function from `src/commands/state.ts`
    so it can be unit-tested directly.
  - '### 4. Blueprint Unit Tests'
  - >-
    I will create the scaffolding for unit tests, focusing on isolated
    functions. These tests will mock external dependencies like the filesystem
    and child processes to ensure they are fast and deterministic.
  - '### 5. Blueprint Integration Tests'
  - >-
    I will blueprint integration tests that verify interactions between
    application code and the filesystem. These tests will use a temporary
    directory to ensure they are isolated and don't affect the project state.
  - '### 6. Blueprint End-to-End Tests'
  - >-
    Finally, I will create a blueprint for end-to-end tests that run the
    compiled CLI application as a child process. This will validate the
    application from the user's perspective, checking command execution and
    output.
operations:
  - type: write
    path: jest.config.js
    content: |
      <<<<<<< SEARCH
        testMatch: ['**/__tests__/**/*.ts?(x)', '**/?(*.)+(spec|test).ts?(x)'],
      =======
        testMatch: ['<rootDir>/test/**/*.test.ts'],
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: delete
    path: unit/.gitkeep
  - type: delete
    path: integration/.gitkeep
  - type: delete
    path: e2e/.gitkeep
  - type: write
    path: src/commands/state.ts
    content: >+
      --- src/commands/state.ts

      +++ src/commands/state.ts

      @@ -6,7 +6,7 @@
        * @param length - The character length of the bar.
        * @returns A string representing the progress bar.
        */
      -const renderProgressBar = (current: number, total: number, length: number
      = 20): string => {

      +export const renderProgressBar = (current: number, total: number, length:
      number = 20): string => {
         // TODO: part-state-render-progress - Implement progress bar rendering logic.
         // INSTRUCTIONS:
         // 1. Calculate the percentage of `current` to `total`.

    patchStrategy: standard-diff
  - type: write
    path: test/unit/commands/state.test.ts
    content: |-
      import { renderProgressBar } from '../../../src/commands/state';

      describe('state command helpers', () => {
        describe('renderProgressBar', () => {
          // TODO: Test case for 0% progress.
          // It should render an empty bar with correct labels.
          it('should render an empty bar for 0 progress', () => {});

          // TODO: Test case for 50% progress.
          // It should render a half-filled bar.
          it('should render a half-filled bar for 50% progress', () => {});

          // TODO: Test case for 100% progress.
          // It should render a full bar.
          it('should render a full bar for 100% progress', () => {});

          // TODO: Test case with a different bar length.
          // It should respect the length parameter.
          it('should handle different bar lengths', () => {});

          // TODO: Test case for a total of 0.
          // It should not throw an error and should render an empty bar.
          it('should handle a total of 0 gracefully', () => {});
        });
      });
    patchStrategy: replace
  - type: write
    path: test/unit/utils/fs.test.ts
    content: >-
      import { getPhaseStats, getFailedReports, readPlan } from
      '../../../src/utils/fs';

      import fs from 'fs/promises';

      import yaml from 'js-yaml';

      import dayjs from 'dayjs';


      // TODO: Mock the 'fs/promises' module to control filesystem operations.

      // jest.mock('fs/promises');


      describe('utils/fs', () => {
        describe('getPhaseStats', () => {
          // TODO: Test case where .nocaflow directory exists with plans.
          // It should correctly count plans in todo, doing, done, etc., for each phase.
          it('should correctly count plans across different statuses and phases', async () => {});

          // TODO: Test case where a phase directory is missing.
          // It should handle the error gracefully and count as 0.
          it('should return 0 for a missing phase directory', async () => {});

          // TODO: Test case where a status directory is missing (e.g., no 'review' plans).
          // It should count that status as 0.
          it('should return 0 for a missing status directory', async () => {});

          // TODO: Test case with an empty .nocaflow directory.
          // All counts should be 0.
          it('should return all zeros for an empty directory structure', async () => {});
        });

        describe('getFailedReports', () => {
          // TODO: Test case with recent and old failure reports.
          // It should only return reports within the specified `hours` lookback period.
          it('should only return reports within the lookback period', async () => {});

          // TODO: Test case where report files have correctly formatted names and content.
          // It should correctly parse planId, partId, and summary from the filename and content.
          it('should correctly parse report details', async () => {});

          // TODO: Test case with no report files.
          // It should return an empty array.
          it('should return an empty array when no reports are found', async () => {});

          // TODO: Test case where a report file is malformed (e.g., no "## Summary" section).
          // It should handle the parsing error gracefully.
          it('should handle malformed report content', async () => {});
        });

        describe('readPlan', () => {
          // TODO: Test case with a valid YAML plan file.
          // It should correctly parse the YAML into a Plan object.
          it('should parse a valid plan file', async () => {});

          // TODO: Test case with a non-existent file path.
          // It should throw a file-not-found error.
          it('should throw an error for a non-existent file', async () => {});

          // TODO: Test case with an invalid YAML file.
          // It should throw a YAML parsing error.
          it('should throw an error for invalid YAML', async () => {});
        });
      });
    patchStrategy: replace
  - type: write
    path: test/unit/utils/git.test.ts
    content: >-
      import { getGitLog } from '../../../src/utils/git';

      import { exec } from 'child_process';


      // TODO: Mock the 'child_process' module to control shell command
      execution.

      // jest.mock('child_process');


      describe('utils/git', () => {
        describe('getGitLog', () => {
          // TODO: Test case with git log output containing worktree information.
          // It should correctly parse the commit hash, message, and worktree name.
          it('should parse commits with worktree information', async () => {});

          // TODO: Test case with git log output for commits not in a worktree (e.g., on main).
          // The 'worktree' property should be null.
          it('should handle commits not associated with a worktree', async () => {});

          // TODO: Test case where `git worktree list` command fails.
          // It should gracefully handle the error and continue, possibly with null worktrees.
          it('should handle git worktree command failure', async () => {});

          // TODO: Test case where `git log` command fails.
          // It should return an empty array or throw an error.
          it('should return an empty array if git log fails', async () => {});

          // TODO: Test case with an empty git log output.
          // It should return an empty array.
          it('should return an empty array for an empty git log', async () => {});
        });
      });
    patchStrategy: replace
  - type: write
    path: test/unit/utils/logs.test.ts
    content: |-
      import { getRecentLogs } from '../../../src/utils/logs';
      import fs from 'fs/promises';

      // TODO: Mock the 'fs/promises' module.
      // jest.mock('fs/promises');

      describe('utils/logs', () => {
        describe('getRecentLogs', () => {
          // TODO: Test case with multiple log files across different phases.
          // It should read from all relevant directories.
          it('should aggregate logs from all phase directories', async () => {});

          // TODO: Test case with a log file containing valid and malformed lines.
          // It should parse valid lines and skip malformed ones.
          it('should correctly parse valid log lines and skip invalid ones', async () => {});

          // TODO: Test case with more log entries than the specified limit.
          // It should return only the most recent 'limit' number of entries, sorted descending by timestamp.
          it('should return the correct number of recent, sorted log entries', async () => {});

          // TODO: Test case where log directories do not exist.
          // It should handle the error and return an empty array.
          it('should return an empty array if log directories are missing', async () => {});

          // TODO: Test case with empty log files.
          // It should return an empty array.
          it('should return an empty array for empty log files', async () => {});
        });
      });
    patchStrategy: replace
  - type: write
    path: test/unit/utils/shell.test.ts
    content: |-
      import { getActiveAgents } from '../../../src/utils/shell';
      import { exec } from 'child_process';
      import dayjs from 'dayjs';

      // TODO: Mock 'child_process'.
      // jest.mock('child_process');

      describe('utils/shell', () => {
        describe('getActiveAgents', () => {
          // TODO: Test case with `tmux ls` output for various agent types.
          // It should correctly parse init, dev, scaffold, and qa agents.
          it('should parse all types of agent sessions', async () => {});

          // TODO: Test case with `tmux ls` output that is empty.
          // It should return an empty array.
          it('should return an empty array when there are no tmux sessions', async () => {});

          // TODO: Test case where `tmux ls` command fails.
          // It should catch the error and return an empty array.
          it('should return an empty array if tmux is not running', async () => {});

          // TODO: Test case to verify runtime calculation.
          // Mocks the current time and session activity timestamp to check the relative time string.
          it('should correctly calculate agent runtime', async () => {});
        });
      });
    patchStrategy: replace
  - type: write
    path: test/integration/commands/init.test.ts
    content: |-
      import { handleInitCommand } from '../../../src/commands/init';
      import fs from 'fs/promises';
      import path from 'path';

      describe('integration/commands/init', () => {
        // TODO: Set up a temporary test directory before each test.
        // Use fs.mkdtemp to create a unique directory in the OS's temp folder.
        // Change the current working directory to the temp directory.
        beforeEach(async () => {});

        // TODO: Clean up the temporary directory after each test.
        // Change back to the original working directory.
        // Use fs.rm with { recursive: true, force: true }.
        afterEach(async () => {});

        // TODO: Test case for a fresh initialization.
        // It should create the full .nocaflow directory structure and all .gitkeep files.
        it('should create the full .nocaflow directory structure on first run', async () => {});

        // TODO: Test case where .nocaflow already exists.
        // The command should log a warning and exit without modifying anything.
        // This requires mocking console.warn and process.exit.
        it('should exit with a warning if .nocaflow directory already exists', async () => {});
      });
    patchStrategy: replace
  - type: write
    path: test/e2e/cli.test.ts
    content: |-
      import { exec } from 'child_process';
      import util from 'util';
      import fs from 'fs/promises';
      import path from 'path';

      const execPromise = util.promisify(exec);

      // TODO: Define path to the compiled CLI entry point.
      const cliPath = 'node dist/cli.js';

      describe('e2e/cli', () => {
        // TODO: Set up a temporary test directory and run `npm run build` before all tests.
        beforeAll(async () => {});

        // TODO: Clean up the temporary directory after all tests.
        afterAll(async () => {});

        // TODO: Set up a temporary CWD for each test.
        beforeEach(async () => {});
        
        // TODO: Clean up CWD after each test.
        afterEach(async () => {});

        describe('init command', () => {
          // TODO: Test `nocaflow init`.
          // It should execute successfully and create the .nocaflow directory.
          // Verify directory structure exists after command runs.
          it('should initialize a new project structure', async () => {});
        });

        describe('state command', () => {
          // TODO: Test `nocaflow state` in an initialized directory.
          // First, run `init`. Then, run `state`.
          // The command should execute successfully and output a formatted state report.
          // The test should check for key headers in the stdout, like "== nocaflow State ==".
          it('should display the project state', async () => {});
        });

        describe('no command', () => {
          // TODO: Test running `nocaflow` with no command.
          // It should display the help message.
          it('should display help when no command is provided', async () => {});
        });
      });
    patchStrategy: replace
snapshot:
  test/unit/commands/state.test.ts: null
  test/unit/utils/fs.test.ts: null
  test/unit/utils/git.test.ts: null
  test/unit/utils/logs.test.ts: null
  test/unit/utils/shell.test.ts: null
  test/integration/commands/init.test.ts: null
  test/e2e/cli.test.ts: null
  jest.config.js: |-
    module.exports = {
      preset: 'ts-jest',
      testEnvironment: 'node',
      testMatch: ['**/__tests__/**/*.ts?(x)', '**/?(*.)+(spec|test).ts?(x)'],
    };
  unit/.gitkeep: ''
  integration/.gitkeep: ''
  e2e/.gitkeep: ''
  src/commands/state.ts: >-
    import chalk from 'chalk';

    import { getPhaseStats, PhaseStats, getFailedReports, FailedReport } from
    '../utils/fs';

    import { getActiveAgents, AgentInfo } from '../utils/shell';

    import dayjs from 'dayjs';

    import { getRecentLogs, LogEntry } from '../utils/logs';

    import { getGitLog, GitCommit } from '../utils/git';


    /**
     * @description Renders a progress bar.
     * @param current - The current progress value.
     * @param total - The total value for 100%.
     * @param length - The character length of the bar.
     * @returns A string representing the progress bar.
     */
    const renderProgressBar = (current: number, total: number, length: number =
    20): string => {
      // TODO: part-state-render-progress - Implement progress bar rendering logic.
      // INSTRUCTIONS:
      // 1. Calculate the percentage of `current` to `total`.
      // 2. Determine how many `length` characters should be filled (e.g., '▇').
      // 3. Determine how many `length` characters should be empty (e.g., '-').
      // 4. Return a string like `[▇▇▇▇----] (current/total plans done)`.
      // 5. If total is 0, return a string representing an empty bar `[----------] (0/0 plans done)`.

      // const percent = total > 0 ? current / total : 0;
      // const filledLength = Math.round(length * percent);
      // const emptyLength = length - filledLength;
      // const filledBar = '▇'.repeat(filledLength);
      // const emptyBar = '-'.repeat(emptyLength);
      // const bar = `[${filledBar}${emptyBar}]`;
      // const text = `(${current}/${total} plans done)`;

      // return `${bar} ${text}`;

      throw new Error('Not implemented');
    };


    /**
     * @description Displays the full state report to the console.
     */
    export const handleStateCommand = async (argv: {}): Promise<void> => {
      // TODO: part-state-fetch-data - Fetch all necessary data using utility functions.
      // INSTRUCTIONS:
      // 2. Call `getPhaseStats()` to get statistics for all phases.
      // 3. Call `getActiveAgents()` to get a list of running agents.
      // 4. Call `getRecentLogs(5)` to get the last 5 log entries.
      // 5. Call `getFailedReports(24)` to get failures in the last 24 hours.
      // 6. Call `getGitLog(10)` to get the 10 most recent git commits.

      // const phaseStats: PhaseStats = await getPhaseStats();
      // const activeAgents: AgentInfo[] = await getActiveAgents();
      // const recentLogs: LogEntry[] = await getRecentLogs(5);
      // const failedReports: FailedReport[] = await getFailedReports(24);
      // const gitCommits: GitCommit[] = await getGitLog(10);
      // const currentPhase = phaseStats.development?.total > 0 ? 'development' : 'initialization';

      // TODO: part-state-render-output - Format and print the state report.
      // INSTRUCTIONS:
      // 1. Use `chalk` for all coloring to match the style in the project's README.md.
      // 2. Print a header with the current time.
      // 3. Print the current phase.
      // 4. Print phase progress using `renderProgressBar` for each phase found in `phaseStats`.
      // 5. Print detailed plan counts for each phase.
      // 6. Print a list of active agents, including their phase, IDs, and runtime.
      // 7. Print recent agent activity from `recentLogs`, color-coding by status (DONE, FAIL).
      // 8. Print any stalled or failed reports from `failedReports`.
      // 9. Print recent git commits, including hash, worktree (if any), and message.

      /*
      // Header
      console.log(chalk.bold(`== nocaflow State [${dayjs().format('YYYY-MM-DD HH:mm:ss')}] ==`));
      console.log(`Current Phase: ${chalk.cyan(currentPhase)}`);
      
      // Phase Progress
      console.log(chalk.bold('\n== Phase Progress =='));
      // for (const phaseName in phaseStats) { ... renderProgressBar(...) ... }

      // Phase Stats
      console.log(chalk.bold('\n== Phase Stats (Plans) =='));
      // for (const phaseName in phaseStats) { ... console.log(...) ... }

      // Active Agents
      console.log(chalk.bold('\n== Active Agents (tmux) =='));
      // if (activeAgents.length === 0) { console.log('No active agents.'); }
      // for (const agent of activeAgents) { ... console.log(...) ... }

      // Recent Agent Activity
      console.log(chalk.bold('\n== Recent Agent Activity (last 5) =='));
      // if (recentLogs.length === 0) { console.log('No recent activity.'); }
      // for (const log of recentLogs) { ... console.log with color based on log.status ... }

      // Stalled / Failed
      console.log(chalk.bold('\n== Stalled / Failed (last 24h) =='));
      // if (failedReports.length === 0) { console.log('No failed reports in the last 24 hours.'); }
      // for (const report of failedReports) { ... console.log(...) ... }

      // Recent Git Commits
      console.log(chalk.bold('\n== Recent Git Commits (all worktrees) =='));
      // if (gitCommits.length === 0) { console.log('No recent commits.'); }
      // for (const commit of gitCommits) { ... console.log(...) ... }
      */

      throw new Error('Not implemented');
    };
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 8
