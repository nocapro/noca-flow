uuid: 4f145f8f-c8d4-4638-b1de-2bfb31952ab7
projectId: noca-flow
createdAt: '2025-11-11T12:50:24.063Z'
gitCommitMsg: >-
  feat(tests): blueprint comprehensive test cases

  Expands the existing `// TODO:` comments across all test suites (e2e,
  integration, unit) to provide a detailed blueprint for implementation.

  This includes specifying mock setups, function calls, and expected assertions
  for various scenarios and edge cases, covering CLI commands, filesystem
  utilities, git interactions, and shell command parsing. This serves as a clear
  cheatsheet to guide the implementation of a robust test suite.
promptSummary: >-
  The user wants to blueprint more test cases for the `nocaflow` project by
  adding detailed `// TODO:` comments to all existing test files. The goal is to
  create a "cheatsheet" for a future AI developer to implement the tests.
reasoning:
  - >-
    Excellent. Blueprinting the test suite is a critical step. I will now expand
    the `// TODO:` comments in the test files to provide a clear, actionable
    cheatsheet for the next AI developer. My focus is on defining *what* to
    test, including setup, execution, and assertions for various scenarios and
    edge cases.
  - '### `test/e2e/cli.test.ts`'
  - >-
    First, I'll flesh out the e2e test file. This involves defining the setup
    and teardown process for creating an isolated test environment and adding
    more specific assertions for the CLI commands.
  - '### `test/integration/commands/init.test.ts`'
  - >-
    Next, I'll enhance the integration test for the `init` command, focusing on
    mocking and detailed setup/teardown logic.
  - '### `test/unit/commands/state.test.ts`'
  - >-
    Here, I'll detail the assertions for the `renderProgressBar` helper
    function, covering all its edge cases.
  - '### `test/unit/utils/fs.test.ts`'
  - >-
    This is a key file. I'll add specific mocking instructions and test cases
    for all exported functions.
  - '### `test/unit/utils/git.test.ts`'
  - >-
    Now for the Git utility, specifying how to mock `child_process.exec` and
    testing the parsing logic.
  - '### `test/unit/utils/logs.test.ts`'
  - Here, I'll define tests for the log parsing and aggregation logic.
  - '### `test/unit/utils/shell.test.ts`'
  - >-
    Finally, I'll blueprint the tests for the shell utility, focusing on parsing
    different `tmux` command outputs.
  - >-
    This completes the blueprinting. Each test file now has a clear and detailed
    set of instructions for implementation.
operations:
  - type: write
    path: test/e2e/cli.test.ts
    content: >+
      --- test/e2e/cli.test.ts

      +++ test/e2e/cli.test.ts

      @@ -6,51 +6,80 @@
       const execPromise = util.promisify(exec);
       
       // TODO: Define path to the compiled CLI entry point.
      -const cliPath = 'node dist/cli.js';

      +const cliCommand = 'node ../../dist/cli.js'; // Relative to the test CWD

      +const testDir = path.join(__dirname, 'temp-e2e');
       
       describe('e2e/cli', () => {
         // TODO: Set up a temporary test directory and run `npm run build` before all tests.
      -  beforeAll(async () => {});

      +  // 1. Delete the temp-e2e directory if it exists.

      +  // 2. Create a fresh temp-e2e directory.

      +  // 3. Run `npm run build` from the project root to ensure dist/ is
      up-to-date.

      +  beforeAll(async () => {}, 30000); // Increase timeout for build step
       
         // TODO: Clean up the temporary directory after all tests.
      -  afterAll(async () => {});

      +  // 1. Remove the temp-e2e directory.

      +  afterAll(async () => {});
       
         // TODO: Set up a temporary CWD for each test.
      -  beforeEach(async () => {});

      +  // 1. Create a unique subdirectory inside 'temp-e2e' for the test.

      +  // 2. Change the current working directory to this new subdirectory.

      +  beforeEach(async () => {});
         
         // TODO: Clean up CWD after each test.
      -  afterEach(async () => {});

      +  // 1. Change CWD back to the project root.

      +  // 2. The main temp-e2e directory will be cleaned up in afterAll.

      +  afterEach(async () => {});
       
         describe('init command', () => {
           // TODO: Test `nocaflow init`.
           // It should execute successfully and create the .nocaflow directory.
           // Verify directory structure exists after command runs.
      -    it('should initialize a new project structure', async () => {});

      +    // 1. Run `nocaflow init`.

      +    // 2. Check for the existence of
      `.nocaflow/initialization/plans/todo/.gitkeep`.

      +    // 3. Check for the existence of
      `.nocaflow/development/plans/todo/.gitkeep`.

      +    // 4. Assert that the command's stdout contains a success message.

      +    it('should initialize a new project structure', async () => {});
         });
       
         describe('state command', () => {
           // TODO: Test `nocaflow state` in an initialized directory.
           // First, run `init`. Then, run `state`.
           // The command should execute successfully and output a formatted state report.
      -    // The test should check for key headers in the stdout, like "==
      nocaflow State ==".

      -    it('should display the project state', async () => {});

      +    // The test should check for key headers in the stdout.

      +    // 1. Run `nocaflow init`.

      +    // 2. Run `nocaflow state`.

      +    // 3. Assert that stdout includes "== nocaflow State ==".

      +    // 4. Assert that stdout includes "Current Phase: initialization".

      +    // 5. Assert that stdout includes "== Phase Progress ==".

      +    it('should display the project state in an initialized directory',
      async () => {});

      +

      +    // TODO: Test `nocaflow state` in a directory that has not been
      initialized.

      +    // 1. Run `nocaflow state`.

      +    // 2. The command should exit with a non-zero status code.

      +    // 3. Assert that stderr contains an error message about `.nocaflow`
      not being found.

      +    it('should show an error when run in a non-initialized directory',
      async () => {});
         });
       
         describe('no command', () => {
           // TODO: Test running `nocaflow` with no command.
           // It should display the help message.
      +    // 1. Run `nocaflow` with no arguments.

      +    // 2. Assert that stdout includes the help text (e.g., "Commands:",
      "Options:").
           it('should display help when no command is provided', async () => {});
         });
       });

    patchStrategy: standard-diff
  - type: write
    path: test/integration/commands/init.test.ts
    content: >+
      --- test/integration/commands/init.test.ts

      +++ test/integration/commands/init.test.ts

      @@ -7,27 +7,43 @@
         // TODO: Set up a temporary test directory before each test.
         // Use fs.mkdtemp to create a unique directory in the OS's temp folder.
         // Change the current working directory to the temp directory.
      -  beforeEach(async () => {});

      +  // 1. Store the original CWD.

      +  // 2. Create a temp directory using `fs.mkdtemp`.

      +  // 3. Change CWD to the temp directory.

      +  beforeEach(async () => {});
       
         // TODO: Clean up the temporary directory after each test.
         // Change back to the original working directory.
         // Use fs.rm with { recursive: true, force: true }.
      -  afterEach(async () => {});

      +  // 1. Change CWD back to the original CWD.

      +  // 2. Remove the temp directory.

      +  afterEach(async () => {});
       
         // TODO: Test case for a fresh initialization.
         // It should create the full .nocaflow directory structure and all .gitkeep files.
      -  it('should create the full .nocaflow directory structure on first run',
      async () => {});

      +  // 1. Call `handleInitCommand({})`.

      +  // 2. Use `fs.access` to verify that several key directories exist.

      +  //    - e.g., '.nocaflow/initialization/plans/todo'

      +  //    - e.g., '.nocaflow/development/plans/failed/report'

      +  // 3. Use `fs.access` to verify that several key `.gitkeep` files
      exist.

      +  //    - e.g., '.nocaflow/initialization/agent-log/.gitkeep'

      +  it('should create the full .nocaflow directory structure on first run',
      async () => {});
       
         // TODO: Test case where .nocaflow already exists.
         // The command should log a warning and exit without modifying anything.
         // This requires mocking console.warn and process.exit.
      -  it('should exit with a warning if .nocaflow directory already exists',
      async () => {});

      +  // 1. Mock `console.warn` and `process.exit` with `jest.spyOn`.

      +  // 2. Create the `.nocaflow` directory manually.

      +  // 3. Call `handleInitCommand({})`.

      +  // 4. Assert that `console.warn` was called with a specific message.

      +  // 5. Assert that `process.exit` was called.

      +  it('should exit with a warning if .nocaflow directory already exists',
      async () => {});
       });

    patchStrategy: standard-diff
  - type: write
    path: test/unit/commands/state.test.ts
    content: >+
      --- test/unit/commands/state.test.ts

      +++ test/unit/commands/state.test.ts

      @@ -5,26 +5,42 @@
         describe('renderProgressBar', () => {
           // TODO: Test case for 0% progress.
           // It should render an empty bar with correct labels.
      -    it('should render an empty bar for 0 progress', () => {});

      +    // 1. Call `renderProgressBar(0, 10, 10)`.

      +    // 2. Assert the output is `[----------] (0/10 plans done)`.

      +    it('should render an empty bar for 0 progress', () => {});
       
           // TODO: Test case for 50% progress.
           // It should render a half-filled bar.
      -    it('should render a half-filled bar for 50% progress', () => {});

      +    // 1. Call `renderProgressBar(5, 10, 10)`.

      +    // 2. Assert the output is `[▇▇▇▇▇-----] (5/10 plans done)`.

      +    it('should render a half-filled bar for 50% progress', () => {});
       
           // TODO: Test case for 100% progress.
           // It should render a full bar.
      -    it('should render a full bar for 100% progress', () => {});

      +    // 1. Call `renderProgressBar(10, 10, 10)`.

      +    // 2. Assert the output is `[▇▇▇▇▇▇▇▇▇▇] (10/10 plans done)`.

      +    it('should render a full bar for 100% progress', () => {});
       
           // TODO: Test case with a different bar length.
           // It should respect the length parameter.
      -    it('should handle different bar lengths', () => {});

      +    // 1. Call `renderProgressBar(1, 2, 20)`.

      +    // 2. Assert the filled part has 10 '▇' characters.

      +    it('should handle different bar lengths', () => {});

      +

      +    // TODO: Test case for progress that isn't a clean fraction.

      +    // It should round to the nearest whole character.

      +    // 1. Call `renderProgressBar(1, 3, 10)`.

      +    // 2. 33% should round to 3 filled characters.

      +    // 3. Assert the output is `[▇▇▇-------] (1/3 plans done)`.

      +    it('should round to the nearest character for fractional progress',
      () => {});
       
           // TODO: Test case for a total of 0.
           // It should not throw an error and should render an empty bar.
      -    it('should handle a total of 0 gracefully', () => {});

      +    // 1. Call `renderProgressBar(0, 0, 10)`.

      +    // 2. Assert it does not throw a "division by zero" error.

      +    // 3. Assert the output is `[----------] (0/0 plans done)`.

      +    it('should handle a total of 0 gracefully', () => {});
         });
       });

    patchStrategy: standard-diff
  - type: write
    path: test/unit/utils/fs.test.ts
    content: >+
      --- test/unit/utils/fs.test.ts

      +++ test/unit/utils/fs.test.ts

      @@ -5,69 +5,116 @@
       import dayjs from 'dayjs';
       
       // TODO: Mock the 'fs/promises' module to control filesystem operations.
      -// jest.mock('fs/promises');

      +jest.mock('fs/promises');

      +const mockedFs = fs as jest.Mocked<typeof fs>;
       
       describe('utils/fs', () => {
      +  afterEach(() => {

      +    jest.clearAllMocks();

      +  });

      +
         describe('getPhaseStats', () => {
           // TODO: Test case where .nocaflow directory exists with plans.
           // It should correctly count plans in todo, doing, done, etc., for each phase.
      -    it('should correctly count plans across different statuses and
      phases', async () => {});

      +    // 1. Mock `fs.readdir` to return different arrays of filenames for
      different paths.

      +    //    - e.g., `.../initialization/plans/todo` -> `['a.yml', 'b.yml']`
      (count: 2)

      +    //    - e.g., `.../development/plans/done` -> `['c.yml']` (count: 1)

      +    // 2. Call `getPhaseStats()`.

      +    // 3. Assert `stats.initialization.todo` is 2 and
      `stats.development.done` is 1.

      +    // 4. Assert `total` is calculated correctly for each phase.

      +    it('should correctly count plans across different statuses and
      phases', async () => {});
       
           // TODO: Test case where a phase directory is missing.
           // It should handle the error gracefully and count as 0.
      -    it('should return 0 for a missing phase directory', async () => {});

      +    // 1. Mock `fs.readdir` to throw an ENOENT error for any path under
      `.../development/...`.

      +    // 2. Call `getPhaseStats()`.

      +    // 3. Assert all counts for `development` are 0.

      +    it('should return 0 for a missing phase directory', async () => {});
       
           // TODO: Test case where a status directory is missing (e.g., no 'review' plans).
           // It should count that status as 0.
      -    it('should return 0 for a missing status directory', async () => {});

      +    // 1. Mock `fs.readdir` to throw an ENOENT error for
      `.../initialization/plans/review`.

      +    // 2. Call `getPhaseStats()`.

      +    // 3. Assert `stats.initialization.review` is 0.

      +    it('should return 0 for a missing status directory', async () => {});
       
           // TODO: Test case with an empty .nocaflow directory.
           // All counts should be 0.
      -    it('should return all zeros for an empty directory structure', async
      () => {});

      +    // 1. Mock `fs.readdir` to return `[]` for all status directories.

      +    // 2. Call `getPhaseStats()`.

      +    // 3. Assert all counts for all phases are 0.

      +    it('should return all zeros for an empty directory structure', async
      () => {});
         });
       
         describe('getFailedReports', () => {
           // TODO: Test case with recent and old failure reports.
           // It should only return reports within the specified `hours` lookback period.
      -    it('should only return reports within the lookback period', async ()
      => {});

      +    // 1. Mock `fs.readdir` to return two report files.

      +    // 2. Mock `fs.stat` to return a recent `birthtime` for one and an
      old `birthtime` for the other.

      +    // 3. Mock `fs.readFile` for the recent file.

      +    // 4. Call `getFailedReports(24)`.

      +    // 5. Assert the result contains only the recent report.

      +    it('should only return reports within the lookback period', async ()
      => {});
       
           // TODO: Test case where report files have correctly formatted names and content.
           // It should correctly parse planId, partId, and summary from the filename and content.
      -    it('should correctly parse report details', async () => {});

      +    // 1. Mock `fs.readdir` to return `['plan1.partA.report.md']`.

      +    // 2. Mock `fs.stat` to return a recent `birthtime`.

      +    // 3. Mock `fs.readFile` to return markdown with `## Summary\nThis is
      the reason.`.

      +    // 4. Call `getFailedReports(24)`.

      +    // 5. Assert `result[0].planId` is 'plan1', `partId` is 'partA', and
      `reason` is 'This is the reason.'.

      +    it('should correctly parse report details', async () => {});
       
           // TODO: Test case with no report files.
           // It should return an empty array.
      -    it('should return an empty array when no reports are found', async ()
      => {});

      +    // 1. Mock `fs.readdir` to return `[]`.

      +    // 2. Call `getFailedReports(24)`.

      +    // 3. Assert the result is an empty array.

      +    it('should return an empty array when no reports are found', async ()
      => {});
       
           // TODO: Test case where a report file is malformed (e.g., no "## Summary" section).
           // It should handle the parsing error gracefully.
      -    it('should handle malformed report content', async () => {});

      +    // 1. Mock `fs.readdir` and `fs.stat` for a recent report.

      +    // 2. Mock `fs.readFile` to return content *without* a `## Summary`
      section.

      +    // 3. Call `getFailedReports(24)`.

      +    // 4. Assert the `reason` field has a sensible fallback, like 'Could
      not parse summary.'.

      +    it('should handle malformed report content', async () => {});
         });
       
         describe('readPlan', () => {
           // TODO: Test case with a valid YAML plan file.
           // It should correctly parse the YAML into a Plan object.
      -    it('should parse a valid plan file', async () => {});

      +    // 1. Mock `fs.readFile` to return a valid YAML string.

      +    // 2. Call `readPlan('path/to/plan.yml')`.

      +    // 3. Assert that the returned object matches the parsed structure of
      the YAML.

      +    it('should parse a valid plan file', async () => {});
       
           // TODO: Test case with a non-existent file path.
           // It should throw a file-not-found error.
      -    it('should throw an error for a non-existent file', async () => {});

      +    // 1. Mock `fs.readFile` to throw an error with `code: 'ENOENT'`.

      +    // 2. Call `readPlan` and assert that it throws an error.

      +    it('should throw an error for a non-existent file', async () => {});
       
           // TODO: Test case with an invalid YAML file.
           // It should throw a YAML parsing error.
      -    it('should throw an error for invalid YAML', async () => {});

      +    // 1. Mock `fs.readFile` to return a string with invalid YAML syntax
      (e.g., `key: - invalid:`).

      +    // 2. Call `readPlan` and assert that it throws a YAMLException.

      +    it('should throw an error for invalid YAML', async () => {});
         });
       });

    patchStrategy: standard-diff
  - type: write
    path: test/unit/utils/git.test.ts
    content: >+
      --- test/unit/utils/git.test.ts

      +++ test/unit/utils/git.test.ts

      @@ -2,53 +2,81 @@
       import { getGitLog } from '../../../src/utils/git';
       import { exec } from 'child_process';
       
      -// TODO: Mock the 'child_process' module to control shell command
      execution.

      -// jest.mock('child_process');

      +jest.mock('child_process');

      +const mockedExec = exec as jest.Mock;
       
       describe('utils/git', () => {
      +  afterEach(() => {

      +    jest.clearAllMocks();

      +  });

      +
         describe('getGitLog', () => {
           // TODO: Test case with git log output containing worktree information.
           // It should correctly parse the commit hash, message, and worktree name.
      -    it('should parse commits with worktree information', async () => {});

      +    // 1. Mock `exec` to return porcelain worktree list output for `git
      worktree list`.

      +    // 2. Mock `exec` to return formatted log output for `git log`, where
      one entry has a ref like `HEAD -> worktrees/my-feature`.

      +    // 3. Call `getGitLog(5)`.

      +    // 4. Find the corresponding commit in the result and assert its
      `worktree` property is `my-feature`.

      +    it('should parse commits with worktree information', async () => {});
       
           // TODO: Test case with git log output for commits not in a worktree (e.g., on main).
           // The 'worktree' property should be null.
      -    it('should handle commits not associated with a worktree', async ()
      => {});

      +    // 1. Mock `exec` for worktrees and logs.

      +    // 2. Ensure one log entry has refs like `HEAD -> main, origin/main`.

      +    // 3. Call `getGitLog(5)`.

      +    // 4. Find that commit and assert its `worktree` property is `null`.

      +    it('should handle commits not associated with a worktree', async ()
      => {});
       
           // TODO: Test case where `git worktree list` command fails.
           // It should gracefully handle the error and continue, possibly with null worktrees.
      -    it('should handle git worktree command failure', async () => {});

      +    // 1. Mock `exec` to throw an error when the command is `git worktree
      list --porcelain`.

      +    // 2. Mock `exec` to return valid log output for `git log`.

      +    // 3. Call `getGitLog(5)`.

      +    // 4. Assert that the function does not throw.

      +    // 5. Assert that all returned commits have `worktree: null`.

      +    it('should handle git worktree command failure', async () => {});
       
           // TODO: Test case where `git log` command fails.
           // It should return an empty array or throw an error.
      -    it('should return an empty array if git log fails', async () => {});

      +    // 1. Mock `exec` to return valid worktree info.

      +    // 2. Mock `exec` to throw an error when the command is `git log
      ...`.

      +    // 3. Call `getGitLog(5)`.

      +    // 4. Assert that the result is an empty array.

      +    it('should return an empty array if git log fails', async () => {});
       
           // TODO: Test case with an empty git log output.
           // It should return an empty array.
      -    it('should return an empty array for an empty git log', async () =>
      {});

      +    // 1. Mock `exec` for worktrees.

      +    // 2. Mock `exec` for `git log` to return an empty string in stdout.

      +    // 3. Call `getGitLog(5)`.

      +    // 4. Assert the result is an empty array.

      +    it('should return an empty array for an empty git log', async () =>
      {});
         });
       });

    patchStrategy: standard-diff
  - type: write
    path: test/unit/utils/logs.test.ts
    content: >+
      --- test/unit/utils/logs.test.ts

      +++ test/unit/utils/logs.test.ts

      @@ -2,50 +2,78 @@
       import { getRecentLogs } from '../../../src/utils/logs';
       import fs from 'fs/promises';
       
      -// TODO: Mock the 'fs/promises' module.

      -// jest.mock('fs/promises');

      +jest.mock('fs/promises');

      +const mockedFs = fs as jest.Mocked<typeof fs>;
       
       describe('utils/logs', () => {
      +  afterEach(() => {

      +    jest.clearAllMocks();

      +  });

      +
         describe('getRecentLogs', () => {
           // TODO: Test case with multiple log files across different phases.
           // It should read from all relevant directories.
      -    it('should aggregate logs from all phase directories', async () =>
      {});

      +    // 1. Mock `fs.readdir` to return `['a.log']` for the init dir and
      `['b.log']` for the dev dir.

      +    // 2. Mock `fs.readFile` to return different log content for `a.log`
      and `b.log`.

      +    // 3. Call `getRecentLogs(10)`.

      +    // 4. Assert that the result contains parsed entries from both files.

      +    it('should aggregate logs from all phase directories', async () =>
      {});
       
           // TODO: Test case with a log file containing valid and malformed lines.
           // It should parse valid lines and skip malformed ones.
      -    it('should correctly parse valid log lines and skip invalid ones',
      async () => {});

      +    // 1. Mock `fs.readdir` to return one log file.

      +    // 2. Mock `fs.readFile` to return a string with one valid log line
      and one invalid line.

      +    // 3. Call `getRecentLogs(10)`.

      +    // 4. Assert that the result contains exactly one entry,
      corresponding to the valid line.

      +    it('should correctly parse valid log lines and skip invalid ones',
      async () => {});
       
           // TODO: Test case with more log entries than the specified limit.
           // It should return only the most recent 'limit' number of entries, sorted descending by timestamp.
      -    it('should return the correct number of recent, sorted log entries',
      async () => {});

      +    // 1. Mock `fs.readdir` and `fs.readFile` to produce 10 log entries
      with out-of-order timestamps.

      +    // 2. Call `getRecentLogs(5)`.

      +    // 3. Assert the result has a length of 5.

      +    // 4. Assert the timestamps in the result are in descending order.

      +    it('should return the correct number of recent, sorted log entries',
      async () => {});
       
           // TODO: Test case where log directories do not exist.
           // It should handle the error and return an empty array.
      -    it('should return an empty array if log directories are missing',
      async () => {});

      +    // 1. Mock `fs.readdir` to throw an ENOENT error for all log
      directories.

      +    // 2. Call `getRecentLogs(5)`.

      +    // 3. Assert the result is an empty array.

      +    it('should return an empty array if log directories are missing',
      async () => {});
       
           // TODO: Test case with empty log files.
           // It should return an empty array.
      -    it('should return an empty array for empty log files', async () =>
      {});

      +    // 1. Mock `fs.readdir` to return log file names.

      +    // 2. Mock `fs.readFile` to return an empty string for all files.

      +    // 3. Call `getRecentLogs(5)`.

      +    // 4. Assert the result is an empty array.

      +    it('should return an empty array for empty log files', async () =>
      {});
         });
       });

    patchStrategy: standard-diff
  - type: write
    path: test/unit/utils/shell.test.ts
    content: >+
      --- test/unit/utils/shell.test.ts

      +++ test/unit/utils/shell.test.ts

      @@ -3,41 +3,65 @@
       import { exec } from 'child_process';
       import dayjs from 'dayjs';
       
      -// TODO: Mock 'child_process'.

      -// jest.mock('child_process');

      +jest.mock('child_process');

      +const mockedExec = exec as jest.Mock;
       
       describe('utils/shell', () => {
      +  afterEach(() => {

      +    jest.clearAllMocks();

      +  });

      +
         describe('getActiveAgents', () => {
           // TODO: Test case with `tmux ls` output for various agent types.
           // It should correctly parse init, dev, scaffold, and qa agents.
      -    it('should parse all types of agent sessions', async () => {});

      +    // 1. Mock `exec` to return a multi-line string with session names
      like:

      +    //    - `init-part1 123 1672531200`

      +    //    - `dev-part2 456 1672531200`

      +    //    - `init-scaffold-plan1 789 1672531200`

      +    //    - `qa-plan2 101 1672531200`

      +    //    - `non-agent-session 112 1672531200`

      +    // 2. Call `getActiveAgents()`.

      +    // 3. Assert the result contains 4 agents.

      +    // 4. Assert each agent has the correct phase, planId, partId, etc.

      +    it('should parse all types of agent sessions and ignore non-agent
      sessions', async () => {});
       
           // TODO: Test case with `tmux ls` output that is empty.
           // It should return an empty array.
      -    it('should return an empty array when there are no tmux sessions',
      async () => {});

      +    // 1. Mock `exec` to return stdout as an empty string.

      +    // 2. Call `getActiveAgents()`.

      +    // 3. Assert the result is an empty array.

      +    it('should return an empty array when there are no tmux sessions',
      async () => {});
       
           // TODO: Test case where `tmux ls` command fails.
           // It should catch the error and return an empty array.
      -    it('should return an empty array if tmux is not running', async () =>
      {});

      +    // 1. Mock `exec` to throw an error.

      +    // 2. Call `getActiveAgents()`.

      +    // 3. Assert the result is an empty array.

      +    it('should return an empty array if tmux is not running', async () =>
      {});
       
           // TODO: Test case to verify runtime calculation.
           // Mocks the current time and session activity timestamp to check the relative time string.
      -    it('should correctly calculate agent runtime', async () => {});

      +    // 1. Mock `Date.now` or use a time-mocking library to control "now".

      +    // 2. Mock `exec` to return a session with a specific activity
      timestamp.

      +    // 3. Call `getActiveAgents()`.

      +    // 4. Assert the `runtime` string is the expected relative time
      (e.g., "5 minutes").

      +    it('should correctly calculate agent runtime', async () => {});
         });
       });

    patchStrategy: standard-diff
snapshot:
  test/e2e/cli.test.ts: |-
    import { exec } from 'child_process';
    import util from 'util';
    import fs from 'fs/promises';
    import path from 'path';

    const execPromise = util.promisify(exec);

    // TODO: Define path to the compiled CLI entry point.
    const cliPath = 'node dist/cli.js';

    describe('e2e/cli', () => {
      // TODO: Set up a temporary test directory and run `npm run build` before all tests.
      beforeAll(async () => {});

      // TODO: Clean up the temporary directory after all tests.
      afterAll(async () => {});

      // TODO: Set up a temporary CWD for each test.
      beforeEach(async () => {});
      
      // TODO: Clean up CWD after each test.
      afterEach(async () => {});

      describe('init command', () => {
        // TODO: Test `nocaflow init`.
        // It should execute successfully and create the .nocaflow directory.
        // Verify directory structure exists after command runs.
        it('should initialize a new project structure', async () => {});
      });

      describe('state command', () => {
        // TODO: Test `nocaflow state` in an initialized directory.
        // First, run `init`. Then, run `state`.
        // The command should execute successfully and output a formatted state report.
        // The test should check for key headers in the stdout, like "== nocaflow State ==".
        it('should display the project state', async () => {});
      });

      describe('no command', () => {
        // TODO: Test running `nocaflow` with no command.
        // It should display the help message.
        it('should display help when no command is provided', async () => {});
      });
    });
  test/integration/commands/init.test.ts: |-
    import { handleInitCommand } from '../../../src/commands/init';
    import fs from 'fs/promises';
    import path from 'path';

    describe('integration/commands/init', () => {
      // TODO: Set up a temporary test directory before each test.
      // Use fs.mkdtemp to create a unique directory in the OS's temp folder.
      // Change the current working directory to the temp directory.
      beforeEach(async () => {});

      // TODO: Clean up the temporary directory after each test.
      // Change back to the original working directory.
      // Use fs.rm with { recursive: true, force: true }.
      afterEach(async () => {});

      // TODO: Test case for a fresh initialization.
      // It should create the full .nocaflow directory structure and all .gitkeep files.
      it('should create the full .nocaflow directory structure on first run', async () => {});

      // TODO: Test case where .nocaflow already exists.
      // The command should log a warning and exit without modifying anything.
      // This requires mocking console.warn and process.exit.
      it('should exit with a warning if .nocaflow directory already exists', async () => {});
    });
  test/unit/commands/state.test.ts: |-
    import { renderProgressBar } from '../../../src/commands/state';

    describe('state command helpers', () => {
      describe('renderProgressBar', () => {
        // TODO: Test case for 0% progress.
        // It should render an empty bar with correct labels.
        it('should render an empty bar for 0 progress', () => {});

        // TODO: Test case for 50% progress.
        // It should render a half-filled bar.
        it('should render a half-filled bar for 50% progress', () => {});

        // TODO: Test case for 100% progress.
        // It should render a full bar.
        it('should render a full bar for 100% progress', () => {});

        // TODO: Test case with a different bar length.
        // It should respect the length parameter.
        it('should handle different bar lengths', () => {});

        // TODO: Test case for a total of 0.
        // It should not throw an error and should render an empty bar.
        it('should handle a total of 0 gracefully', () => {});
      });
    });
  test/unit/utils/fs.test.ts: >-
    import { getPhaseStats, getFailedReports, readPlan } from
    '../../../src/utils/fs';

    import fs from 'fs/promises';

    import yaml from 'js-yaml';

    import dayjs from 'dayjs';


    // TODO: Mock the 'fs/promises' module to control filesystem operations.

    // jest.mock('fs/promises');


    describe('utils/fs', () => {
      describe('getPhaseStats', () => {
        // TODO: Test case where .nocaflow directory exists with plans.
        // It should correctly count plans in todo, doing, done, etc., for each phase.
        it('should correctly count plans across different statuses and phases', async () => {});

        // TODO: Test case where a phase directory is missing.
        // It should handle the error gracefully and count as 0.
        it('should return 0 for a missing phase directory', async () => {});

        // TODO: Test case where a status directory is missing (e.g., no 'review' plans).
        // It should count that status as 0.
        it('should return 0 for a missing status directory', async () => {});

        // TODO: Test case with an empty .nocaflow directory.
        // All counts should be 0.
        it('should return all zeros for an empty directory structure', async () => {});
      });

      describe('getFailedReports', () => {
        // TODO: Test case with recent and old failure reports.
        // It should only return reports within the specified `hours` lookback period.
        it('should only return reports within the lookback period', async () => {});

        // TODO: Test case where report files have correctly formatted names and content.
        // It should correctly parse planId, partId, and summary from the filename and content.
        it('should correctly parse report details', async () => {});

        // TODO: Test case with no report files.
        // It should return an empty array.
        it('should return an empty array when no reports are found', async () => {});

        // TODO: Test case where a report file is malformed (e.g., no "## Summary" section).
        // It should handle the parsing error gracefully.
        it('should handle malformed report content', async () => {});
      });

      describe('readPlan', () => {
        // TODO: Test case with a valid YAML plan file.
        // It should correctly parse the YAML into a Plan object.
        it('should parse a valid plan file', async () => {});

        // TODO: Test case with a non-existent file path.
        // It should throw a file-not-found error.
        it('should throw an error for a non-existent file', async () => {});

        // TODO: Test case with an invalid YAML file.
        // It should throw a YAML parsing error.
        it('should throw an error for invalid YAML', async () => {});
      });
    });
  test/unit/utils/git.test.ts: |-
    import { getGitLog } from '../../../src/utils/git';
    import { exec } from 'child_process';

    // TODO: Mock the 'child_process' module to control shell command execution.
    // jest.mock('child_process');

    describe('utils/git', () => {
      describe('getGitLog', () => {
        // TODO: Test case with git log output containing worktree information.
        // It should correctly parse the commit hash, message, and worktree name.
        it('should parse commits with worktree information', async () => {});

        // TODO: Test case with git log output for commits not in a worktree (e.g., on main).
        // The 'worktree' property should be null.
        it('should handle commits not associated with a worktree', async () => {});

        // TODO: Test case where `git worktree list` command fails.
        // It should gracefully handle the error and continue, possibly with null worktrees.
        it('should handle git worktree command failure', async () => {});

        // TODO: Test case where `git log` command fails.
        // It should return an empty array or throw an error.
        it('should return an empty array if git log fails', async () => {});

        // TODO: Test case with an empty git log output.
        // It should return an empty array.
        it('should return an empty array for an empty git log', async () => {});
      });
    });
  test/unit/utils/logs.test.ts: |-
    import { getRecentLogs } from '../../../src/utils/logs';
    import fs from 'fs/promises';

    // TODO: Mock the 'fs/promises' module.
    // jest.mock('fs/promises');

    describe('utils/logs', () => {
      describe('getRecentLogs', () => {
        // TODO: Test case with multiple log files across different phases.
        // It should read from all relevant directories.
        it('should aggregate logs from all phase directories', async () => {});

        // TODO: Test case with a log file containing valid and malformed lines.
        // It should parse valid lines and skip malformed ones.
        it('should correctly parse valid log lines and skip invalid ones', async () => {});

        // TODO: Test case with more log entries than the specified limit.
        // It should return only the most recent 'limit' number of entries, sorted descending by timestamp.
        it('should return the correct number of recent, sorted log entries', async () => {});

        // TODO: Test case where log directories do not exist.
        // It should handle the error and return an empty array.
        it('should return an empty array if log directories are missing', async () => {});

        // TODO: Test case with empty log files.
        // It should return an empty array.
        it('should return an empty array for empty log files', async () => {});
      });
    });
  test/unit/utils/shell.test.ts: |-
    import { getActiveAgents } from '../../../src/utils/shell';
    import { exec } from 'child_process';
    import dayjs from 'dayjs';

    // TODO: Mock 'child_process'.
    // jest.mock('child_process');

    describe('utils/shell', () => {
      describe('getActiveAgents', () => {
        // TODO: Test case with `tmux ls` output for various agent types.
        // It should correctly parse init, dev, scaffold, and qa agents.
        it('should parse all types of agent sessions', async () => {});

        // TODO: Test case with `tmux ls` output that is empty.
        // It should return an empty array.
        it('should return an empty array when there are no tmux sessions', async () => {});

        // TODO: Test case where `tmux ls` command fails.
        // It should catch the error and return an empty array.
        it('should return an empty array if tmux is not running', async () => {});

        // TODO: Test case to verify runtime calculation.
        // Mocks the current time and session activity timestamp to check the relative time string.
        it('should correctly calculate agent runtime', async () => {});
      });
    });
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-11-11T12:51:00.935Z'
status: committed
id: 9
