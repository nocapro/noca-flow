uuid: 44bfb228-569d-48e0-ac5d-24ebf4ff8721
projectId: noca-flow
createdAt: '2025-11-13T03:27:24.306Z'
gitCommitMsg: >-
  fix(tests): resolve test failures, lint errors, and skipped tests

  - Fixes incorrect import path in `test/e2e/cli.test.ts`. - Removes `as any`
  type assertions on `dayjs.extend()` to resolve ESLint errors. - Modifies
  `test/unit/utils/shell.test.ts` to fail explicitly if the `tmux` dependency is
  missing, instead of skipping tests. This enforces a correct test environment
  setup.
promptSummary: Fix failing/skipped tests and linting errors.
reasoning:
  - >-
    ok, got it. test failures, lint errors, and skipped tests are noise. we need
    a clean build. let's eliminate the cruft.
  - >-
    first, the e2e test failure is a simple pathing error.
    `test/e2e/cli.test.ts` is one level deeper than other tests, so its relative
    import for `platform` is wrong. easy fix.
  - >-
    next, the lint errors are all from `dayjs.extend(relativeTime as any)`. that
    `as any` is sloppy. the types from `dayjs` are good enough, we can just
    remove the type assertion. applying this to all three files.
  - >-
    finally, the skipped test in `test/unit/utils/shell.test.ts`. you hate
    skipped tests, so we'll make it fail explicitly if `tmux` isn't found. a
    missing dependency for an integration test should be a failure, not a skip.
    removing the conditional logic (`itif` and the guards in
    `beforeEach`/`afterEach`) will ensure the suite fails hard if the test
    environment is incomplete.
  - this should clean up the test and lint output completely.
operations:
  - type: write
    path: test/e2e/cli.test.ts
    content: |
      <<<<<<< SEARCH
      import { platform } from '../src/utils/platform';
      =======
      import { platform } from '../../src/utils/platform';
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/commands/state.ts
    content: |
      <<<<<<< SEARCH
      dayjs.extend(relativeTime as any);
      =======
      dayjs.extend(relativeTime);
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/utils/shell.ts
    content: |
      <<<<<<< SEARCH
      dayjs.extend(relativeTime as any);
      =======
      dayjs.extend(relativeTime);
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/utils/shell.test.ts
    content: |
      <<<<<<< SEARCH
      dayjs.extend(relativeTime as any);
      =======
      dayjs.extend(relativeTime);
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/utils/shell.test.ts
    content: >+
      --- test/unit/utils/shell.test.ts

      +++ test/unit/utils/shell.test.ts

      @@ -19,7 +19,6 @@
         });
       
         beforeEach(async () => {
      -    if (!canRun) return;
           // Start detached sessions that will self-terminate
           for (const name of sessionNames) {
             await platform.runCommand(`tmux new-session -d -s ${name} "sleep 10"`);
      @@ -30,7 +29,6 @@
         });
       
         afterEach(async () => {
      -    if (!canRun) return;
           for (const name of sessionNames) {
             // Use `|| true` to ignore errors if session has already terminated or been killed
             await platform.runCommand(`tmux kill-session -t ${name} || true`);
      @@ -38,10 +36,7 @@
         });
       
         describe('getActiveAgents', () => {
      -    const itif = (condition: boolean) => (condition ? it : it.skip);

      -

      -    itif(canRun)('should parse all types of agent sessions and ignore
      non-agent sessions', async () => {

      +    it('should parse all types of agent sessions and ignore non-agent
      sessions', async () => {
             const agents = await getActiveAgents();
             // Filter for agents created in this specific test run to ensure isolation
             const testAgents = agents.filter(
      @@ -60,7 +55,7 @@
             );
           });
       
      -    itif(canRun)('should return an empty array if tmux has no sessions',
      async () => {

      +    it('should return an empty array if tmux has no sessions', async ()
      => {
             // Kill the sessions from beforeEach to create an empty state
             for (const name of sessionNames) {
               await platform.runCommand(`tmux kill-session -t ${name} || true`);
      @@ -70,7 +65,7 @@
             expect(agents).toEqual([]);
           });
       
      -    itif(canRun)('should correctly calculate agent runtime', async () =>
      {

      +    it('should correctly calculate agent runtime', async () => {
             const agents = await getActiveAgents();
             const devAgent = agents.find(a => a.partId === `part456-${testId}`);
             expect(devAgent).toBeDefined();

    patchStrategy: standard-diff
snapshot:
  test/e2e/cli.test.ts: >-
    import { runCli, setupTestDirectory, createDummyPlanFile,
    createDummyFailedReport, initGitRepo } from '../test.util';

    import fs from 'fs/promises';

    import { exec as execCallback } from 'child_process';

    import path from 'path';

    import { promisify } from 'util';

    import { platform } from '../src/utils/platform';


    const promisedExec = promisify(execCallback);



    describe('e2e/cli', () => {
      let cleanup: () => Promise<void>;
      let testDir: string;

      beforeAll(async () => {
        try {
          await promisedExec('npm run build');
        } catch (e) {
          console.error('Failed to build project for E2E tests:', e);
          process.exit(1);
        }
      }, 60000);

      beforeEach(async () => {
        const { cleanup: c, testDir: td } = await setupTestDirectory();
        cleanup = c;
        testDir = td;
      });

      afterEach(async () => {
        if (cleanup) {
          await cleanup();
        }
      });

      describe('init command', () => {
        it('should initialize a new project structure', async () => {
          const { stdout, code } = await runCli('init');

          expect(stdout).toContain('nocaflow project initialized successfully');
          expect(code).toBe(0);

          const expectedFile = path.join(testDir, '.nocaflow/initialization/plans/todo/.gitkeep');
          await expect(fs.access(expectedFile)).resolves.toBeUndefined();
        });

        it('should show a warning if the project is already initialized', async () => {
          await fs.mkdir('.nocaflow'); // Manually create the directory
          const { stderr, code } = await runCli('init');

          expect(stderr).toContain("Warning: '.nocaflow' directory already exists. Initialization skipped.");
          expect(code).toBe(0); // Graceful exit on warning
        });
      });

      describe('state command', () => {
        it('should display the project state in an initialized directory', async () => {
          await runCli('init');
          await createDummyPlanFile('initialization', 'todo', 'plan1.yml');

          const { stdout, code } = await runCli('state');

          expect(stdout).toContain('== nocaflow State');
          expect(stdout).toContain('Phase Progress');
          expect(stdout).toContain('Current Phase: initialization');
          expect(stdout).toContain('todo: 1');
          expect(code).toBe(0);
        });

        it('should display a complex, multi-faceted state correctly', async () => {
          await runCli('init');
          await initGitRepo();

          // Setup: Create various artifacts
          await createDummyPlanFile('initialization', 'doing', 'p1.yml');
          await createDummyPlanFile('development', 'done', 'p2.yml');
          await createDummyFailedReport('initialization', 'f01', 'pA', 'Test failure');

          const logDir = '.nocaflow/development/agent-log';
          await fs.mkdir(logDir, { recursive: true });
          const logContent = `2023-10-27T10:00:00.000Z [DONE|DEV|agent-abc] plan:plan-e2e - Log message`;
          await fs.writeFile(path.join(logDir, 'test.log'), logContent);

          const tmuxSessionName = 'dev-e2e-part-xyz';
          const canRunTmux = await platform.commandExists('tmux');
          if (canRunTmux) {
            await platform.runCommand(`tmux new-session -d -s ${tmuxSessionName} "sleep 15"`);
          }

          // Act: Run the state command
          let stdout: string, code: number;
          try {
            const result = await runCli('state');
            stdout = result.stdout;
            code = result.code;
          } finally {
            // Teardown: ensure tmux session is killed
            if (canRunTmux) {
              await platform.runCommand(`tmux kill-session -t ${tmuxSessionName} || true`);
            }
          }

          expect(code).toBe(0);
          // Assert on all sections
          expect(stdout).toContain('Current Phase: development');
          expect(stdout).toContain('[INITIALIZATION]'.padEnd(18) + '[----------] (0/1 plans done)');
          expect(stdout).toContain('[DEVELOPMENT]'.padEnd(18) + '[▇▇▇▇▇▇▇▇▇▇] (1/1 plans done)');
          if (canRunTmux) {
            expect(stdout).toContain('id:e2e-part-xyz');
          }
          expect(stdout).toContain('plan:plan-e2e - Log message');
          expect(stdout).toContain('plan:f01 part:pA - "Test failure"');
          expect(stdout).toContain('Initial commit');
        });

        it('should show a zero-state when run in a non-initialized directory', async () => {
          const { stdout, stderr, code } = await runCli('state');
          
          expect(stderr).toBe('');
          expect(code).toBe(0);
          expect(stdout).toContain('Current Phase: initialization');
          expect(stdout).toContain('(0/0 plans done)');
          expect(stdout).toContain('No active agents.');
          expect(stdout).toContain('No recent activity.');
          expect(stdout).toContain('No failed reports in the last 24 hours.');
        });
      });

      describe('no command', () => {
        it('should display help when no command is provided', async () => {
          const { stderr } = await runCli('');
          expect(stderr).toContain('Commands:');
          expect(stderr).toContain('init');
          expect(stderr).toContain('state');
          expect(stderr).toContain('You need at least one command before moving on');
        });

        it('should display help when --help flag is used', async () => {
          const generalHelp = await runCli('--help');
          expect(generalHelp.stdout).toContain('Show help');

          const stateHelp = await runCli('state --help');
          expect(stateHelp.stdout).toContain('Display the current state of the nocaflow project');
        });

        it('should show an error for an unknown command', async () => {
          const { stderr } = await runCli('nonexistent-command');
          expect(stderr).toContain('Unknown argument: nonexistent-command');
        });
      });
    });
  src/commands/state.ts: >-
    import chalk from 'chalk';

    import { getPhaseStats, PhaseStats, getFailedReports, FailedReport } from
    '../utils/fs';

    import { getActiveAgents, AgentInfo } from '../utils/shell';

    import dayjs from 'dayjs';

    import relativeTime from 'dayjs/plugin/relativeTime';

    import { getRecentLogs, LogEntry } from '../utils/logs';

    import { getGitLog, GitCommit } from '../utils/git';


    dayjs.extend(relativeTime as any);


    /**
     * @description Renders a progress bar.
     * @param current - The current progress value.
     * @param total - The total value for 100%.
     * @param length - The character length of the bar.
     * @returns A string representing the progress bar.
     */
    export const renderProgressBar = (current: number, total: number, length:
    number = 20): string => {
      const percent = total > 0 ? current / total : 0;
      const filledLength = Math.round(length * percent);
      const emptyLength = length - filledLength;
      const filledBar = '▇'.repeat(filledLength);
      const emptyBar = '-'.repeat(emptyLength);
      const bar = `[${filledBar}${emptyBar}]`;
      const text = `(${current}/${total} plans done)`;

      return `${bar} ${text}`;
    };


    /**
     * @description Displays the full state report to the console.
     */
    export const handleStateCommand = async (_argv: Record<string, unknown>):
    Promise<void> => {
      const phaseStats: PhaseStats = await getPhaseStats();
      const activeAgents: AgentInfo[] = await getActiveAgents();
      const recentLogs: LogEntry[] = await getRecentLogs(5);
      const failedReports: FailedReport[] = await getFailedReports(24);
      const gitCommits: GitCommit[] = await getGitLog(10);
      const currentPhase = phaseStats.development?.total > 0 ? 'development' : 'initialization';

      // Header
      console.log(chalk.bold(`== nocaflow State [${dayjs().format('YYYY-MM-DD HH:mm:ss')}] ==`));
      console.log(`Current Phase: ${chalk.cyan(currentPhase)}`);
      
      // Phase Progress
      console.log(chalk.bold('\n== Phase Progress =='));
      for (const phaseName in phaseStats) {
        const stats = phaseStats[phaseName];
        const progressBar = renderProgressBar(stats.done, stats.total);
        console.log(`[${chalk.yellow(phaseName.toUpperCase())}]`.padEnd(18) + progressBar);
      }

      // Phase Stats
      console.log(chalk.bold('\n== Phase Stats (Plans) =='));
      for (const phaseName in phaseStats) {
        const stats = phaseStats[phaseName];
        if (stats.total === 0) continue;
        const statsString = `todo: ${stats.todo}, doing: ${stats.doing}, review: ${stats.review}, failed: ${stats.failed}, done: ${stats.done}`;
        console.log(`[${chalk.yellow(phaseName.toUpperCase())}]`.padEnd(18) + statsString);
      }

      // Active Agents
      console.log(chalk.bold('\n== Active Agents (tmux) =='));
      if (activeAgents.length === 0) {
        console.log('No active agents.');
      } else {
        for (const agent of activeAgents) {
          console.log(`[${chalk.blue(agent.phase)}|${chalk.magenta(agent.pid)}]`.padEnd(18) + `id:${agent.id} (running ${agent.runtime})`);
        }
      }

      // Recent Agent Activity
      console.log(chalk.bold('\n== Recent Agent Activity (last 5) =='));
      if (recentLogs.length === 0) {
        console.log('No recent activity.');
      } else {
        for (const log of recentLogs) {
          const statusColor = log.status === 'DONE' ? chalk.green : log.status === 'FAIL' ? chalk.red : chalk.gray;
          const time = dayjs(log.timestamp).fromNow();
          console.log(`${statusColor(`[${log.status}|${log.phase}|${log.agentId}]`)} plan:${log.planId} - ${log.message} (${chalk.gray(time)})`);
        }
      }

      // Stalled / Failed
      console.log(chalk.bold('\n== Stalled / Failed (last 24h) =='));
      if (failedReports.length === 0) {
        console.log('No failed reports in the last 24 hours.');
      } else {
        for (const report of failedReports) {
          console.log(`${chalk.red('[FAILED]')} plan:${report.planId} part:${report.partId} - "${report.reason}"`);
          console.log(`         Report: ${report.reportPath}`);
        }
      }

      // Recent Git Commits
      console.log(chalk.bold('\n== Recent Git Commits (all worktrees) =='));
      if (gitCommits.length === 0) {
        console.log('No recent commits.');
      } else {
        for (const commit of gitCommits) {
          const worktreeInfo = commit.worktree ? `(${chalk.cyan(commit.worktree)}) ` : '';
          console.log(`${chalk.yellow(commit.hash.slice(0, 7))} ${worktreeInfo}${commit.message}`);
        }
      }
    };
  src/utils/shell.ts: |-
    import dayjs from 'dayjs';
    import relativeTime from 'dayjs/plugin/relativeTime';
    import { platform } from './platform';

    export interface AgentInfo {
      phase: 'INIT' | 'DEV' | 'QA' | 'SCAF';
      id: string; // part_id, plan_id for QA/Scaffold
      planId: string;
      partId: string; // Can be 'scaffold' or 'qa'
      runtime: string;
      pid: string;
    }

    dayjs.extend(relativeTime as any);

    /**
     * @description Lists active tmux sessions and parses them to find agent info.
     * @returns A list of active agents.
     */
    export const getActiveAgents = async (): Promise<AgentInfo[]> => {
      try {
        const { stdout } = await platform.runCommand(`tmux ls -F "#{session_name} #{pane_pid} #{session_activity}"`);
        if (!stdout) return [];

        const lines = stdout.trim().split('\n');
        const agents: AgentInfo[] = [];

        for (const line of lines) {
          const [sessionName, pid, activity] = line.split(' ');
          const runtime = dayjs().to(dayjs.unix(parseInt(activity, 10)), true);

          let match;
          if ((match = sessionName.match(/^init-scaffold-(.+)/))) {
            const planId = match[1];
            agents.push({
              phase: 'SCAF',
              id: planId,
              planId,
              partId: 'scaffold',
              runtime,
              pid,
            });
          } else if ((match = sessionName.match(/^qa-(.+)/))) {
            const planId = match[1];
            agents.push({ phase: 'QA', id: planId, planId, partId: 'qa', runtime, pid });
          } else if ((match = sessionName.match(/^(init|dev)-(?!scaffold-|qa-)(.+)/))) {
            const phase = match[1].toUpperCase() as 'INIT' | 'DEV';
            const partId = match[2];
            agents.push({
              phase,
              id: partId,
              planId: 'unknown', // Not available from session name
              partId: partId,
              runtime,
              pid,
            });
          }
        }
        return agents;
      } catch (error) {
        return []; // Tmux likely not running or has no sessions.
      }
    };
  test/unit/utils/shell.test.ts: |-
    import { getActiveAgents } from '../../../src/utils/shell';
    import { platform } from '../../../src/utils/platform';
    import dayjs from 'dayjs';
    import relativeTime from 'dayjs/plugin/relativeTime';
    import * as crypto from 'crypto';

    dayjs.extend(relativeTime as any);

    describe('unit/utils/shell (integration)', () => {
      const testId = crypto.randomBytes(4).toString('hex');
      const sessionNames = [
        `init-part123-${testId}`,
        `dev-part456-${testId}`,
        `init-scaffold-plan789-${testId}`,
        `qa-planABC-${testId}`,
        `my-random-session-${testId}`,
      ];

      let canRun = false;

      beforeAll(async () => {
        canRun = await platform.commandExists('tmux');
        if (!canRun) {
          console.warn('`tmux` command not found. Skipping shell integration tests.');
        }
      });

      beforeEach(async () => {
        if (!canRun) return;
        // Start detached sessions that will self-terminate
        for (const name of sessionNames) {
          await platform.runCommand(`tmux new-session -d -s ${name} "sleep 10"`);
        }
        // Give tmux a moment to register all sessions
        await new Promise(resolve => setTimeout(resolve, 200));
      });

      afterEach(async () => {
        if (!canRun) return;
        for (const name of sessionNames) {
          // Use `|| true` to ignore errors if session has already terminated or been killed
          await platform.runCommand(`tmux kill-session -t ${name} || true`);
        }
      });

      describe('getActiveAgents', () => {
        const itif = (condition: boolean) => (condition ? it : it.skip);

        itif(canRun)('should parse all types of agent sessions and ignore non-agent sessions', async () => {
          const agents = await getActiveAgents();
          // Filter for agents created in this specific test run to ensure isolation
          const testAgents = agents.filter(
            a => a.partId.endsWith(testId) || a.planId.endsWith(testId),
          );

          expect(testAgents).toHaveLength(4);

          expect(testAgents).toContainEqual(
            expect.objectContaining({ phase: 'INIT', partId: `part123-${testId}` }),
          );
          expect(testAgents).toContainEqual(
            expect.objectContaining({ phase: 'DEV', partId: `part456-${testId}` }),
          );
          expect(testAgents).toContainEqual(
            expect.objectContaining({ phase: 'SCAF', planId: `plan789-${testId}` }),
          );
          expect(testAgents).toContainEqual(
            expect.objectContaining({ phase: 'QA', planId: `planABC-${testId}` }),
          );
        });

        itif(canRun)('should return an empty array if tmux has no sessions', async () => {
          // Kill the sessions from beforeEach to create an empty state
          for (const name of sessionNames) {
            await platform.runCommand(`tmux kill-session -t ${name} || true`);
          }

          const agents = await getActiveAgents();
          expect(agents).toEqual([]);
        });

        itif(canRun)('should correctly calculate agent runtime', async () => {
          const agents = await getActiveAgents();
          const devAgent = agents.find(a => a.partId === `part456-${testId}`);
          expect(devAgent).toBeDefined();
          // The runtime is short and non-deterministic, just check it exists.
          expect(devAgent?.runtime).toContain('a few seconds');
        });
      });
    });
approved: true
linesAdded: 11
linesRemoved: 19
linesDifference: 30
gitCommittedAt: null
status: committed
id: 43
