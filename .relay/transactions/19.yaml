uuid: a67de54c-113c-424a-a111-a836da8b9e67
projectId: noca-flow
createdAt: '2025-11-12T02:49:58.982Z'
gitCommitMsg: >-
  test: implement unit tests for core utilities

  This commit fulfills Part 3 of the master plan by implementing the complete
  unit test suites for the core data-gathering utilities.

  - `fs.test.ts`: Added tests for `getPhaseStats`, `getFailedReports`,
    and `readPlan`, covering various filesystem states, parsing logic,
    and edge cases like missing files/directories.

  - `logs.test.ts`: Implemented tests for `getRecentLogs` to verify
    log aggregation, sorting, limiting, and parsing of different log
    line formats.

  - `shell.test.ts`: Added tests for `getActiveAgents`, using mocks for
    the external `tmux` command to validate the parsing logic for all
    agent session name conventions and runtime calculations.
promptSummary: >-
  Implement Part 3 of the master plan, which involves writing all the unit tests
  for the core utilities (`fs.ts`, `logs.ts`, `shell.ts`).
reasoning:
  - >-
    Here are the implementations for the unit tests, completing Part 3 of the
    plan.
  - >-
    First, I'll implement the unit tests for the filesystem utilities. These
    tests will verify file counting, report parsing, and plan reading logic,
    ensuring our interactions with the `.nocaflow` directory are robust.
  - >-
    Next, I'll implement the unit tests for the log parsing utility. These tests
    ensure we can correctly read, parse, sort, and filter agent log files.
  - >-
    Finally, I'll implement the unit tests for the shell utility. Since this
    utility interacts with an external command (`tmux`), these tests rely on
    mocking `child_process.exec` to verify our parsing logic in isolation.
operations:
  - type: write
    path: test/unit/utils/fs.test.ts
    content: |
      <<<<<<< SEARCH
          it('should correctly count plans across different statuses and phases', async () => {
            // TODO: part-unit-fs-stats-count - Test plan counting with a populated directory structure.
            // INSTRUCTIONS:
            // 1. Create a `.nocaflow` directory structure.
            //    - e.g., `fs.mkdir('.nocaflow/initialization/plans/todo', { recursive: true })`
            // 2. Create dummy plan files in various status directories.
            //    - e.g., `fs.writeFile('.nocaflow/initialization/plans/todo/a.yml', '')`
            //    - e.g., `fs.writeFile('.nocaflow/development/plans/done/b.yml', '')`
            // 3. Call `getPhaseStats()`.
            // 4. Assert that the returned stats object accurately reflects the file counts.
          });

          it('should return all zeros for an empty directory structure', async () => {
            // TODO: part-unit-fs-stats-empty - Test plan counting with an empty structure.
            // INSTRUCTIONS:
            // 1. Create the top-level `.nocaflow` directory and phase directories, but leave plan folders empty.
            // 2. Call `getPhaseStats()`.
            // 3. Assert that all counts in the returned stats object are 0.
          });

          it('should handle missing status subdirectories gracefully', async () => {
            // TODO: part-unit-fs-stats-missing-subdir - Test plan counting with some status dirs missing.
            // INSTRUCTIONS:
            // 1. Create a structure like `.nocaflow/initialization/plans/` but only create a `todo` subdirectory, not `doing`, `done`, etc.
            // 2. Create a plan file in the `todo` directory.
            // 3. Call `getPhaseStats()`.
            // 4. Assert that the stats for `initialization` show `todo: 1` and `doing: 0`, `done: 0`, etc., without throwing an error.
          });

          it('should handle a missing phase directory gracefully', async () => {
            // TODO: part-unit-fs-stats-missing-phase-dir - Test with a whole phase directory missing.
            // INSTRUCTIONS:
            // 1. Create a structure for `.nocaflow/initialization` with some plans.
            // 2. Do NOT create the `.nocaflow/development` directory at all.
            // 3. Call `getPhaseStats()`.
            // 4. Assert that the stats for `initialization` are correct.
            // 5. Assert that the stats for `development` are all zero and no error was thrown.
          });

          it('should ignore non-YAML files', async () => {
            // TODO: part-unit-fs-stats-ignore-files - Test that non-plan files are not counted.
            // INSTRUCTIONS:
            // 1. Create a `.nocaflow/development/plans/todo` directory.
            // 2. Create `plan1.yml` and `notes.txt` in that directory.
            // 3. Call `getPhaseStats()`.
            // 4. Assert that the `todo` count for `development` is 1, not 2.
          });
        });

        describe('getFailedReports', () => {
          it('should only return reports within the lookback period', async () => {
            // TODO: part-unit-fs-reports-time - Test that only recent reports are returned.
            // INSTRUCTIONS:
            // 1. Create the failed report directory structure.
            // 2. Create two report files: one recent, one old.
            // 3. Use `fs.utimes` or a similar method to modify the `mtime` of the old file to be outside the lookback window.
            // 4. Call `getFailedReports(24)` (for 24 hours).
            // 5. Assert that the result array contains only the recent report.
          });

          it('should correctly parse report details from filename and content', async () => {
            // TODO: part-unit-fs-reports-parse - Test parsing of report details.
            // INSTRUCTIONS:
            // 1. Create a report file named `plan1.partA.report.md`.
            // 2. Write markdown content to it, including a "## Summary" section.
            // 3. Call `getFailedReports(1)`.
            // 4. Assert that the returned `FailedReport` object has `planId: 'plan1'`, `partId: 'partA'`, and the correct `reason` text.
          });

          it('should return an empty array if the report directory does not exist', async () => {
            // TODO: part-unit-fs-reports-no-dir - Test behavior with no report directory.
            // INSTRUCTIONS:
            // 1. Do not create any failed report directories.
            // 2. Call `getFailedReports(24)`.
            // 3. Assert that the result is an empty array.
          });

          it('should gracefully handle malformed report filenames', async () => {
            // TODO: part-unit-fs-reports-bad-name - Test parsing of malformed report names.
            // INSTRUCTIONS:
            // 1. Create a report file named `malformed.report.md` (missing partId).
            // 2. Call `getFailedReports(1)`.
            // 3. Assert that the returned object has sensible defaults (e.g., `planId: 'malformed'`, `partId: undefined`).
          });

          it('should ignore non-markdown report files', async () => {
            // TODO: part-unit-fs-reports-ignore-files - Test that non-report files are ignored.
            // INSTRUCTIONS:
            // 1. Create a failed report directory.
            // 2. Create `plan1.partA.report.md` and `notes.txt`.
            // 3. Call `getFailedReports(1)`.
            // 4. Assert that the result array has a length of 1, containing only the report.
          });
        });

        describe('readPlan', () => {
          it('should parse a valid plan file', async () => {
            // TODO: part-unit-fs-plan-read-success - Test reading a valid YAML plan.
            // INSTRUCTIONS:
            // 1. Define a valid plan object and serialize it to a YAML string.
            // 2. Write this string to a file, e.g., `plan.yml`.
            // 3. Call `readPlan('plan.yml')`.
            // 4. Assert that the returned object deeply equals the original plan object.
          });

          it('should throw an error for a non-existent file', async () => {
            // TODO: part-unit-fs-plan-read-no-file - Test behavior when file is missing.
            // INSTRUCTIONS:
            // 1. Call `readPlan('non-existent-plan.yml')`.
            // 2. Assert that the call rejects with an error (e.g., using `expect(...).rejects.toThrow()`).
          });

          it('should throw an error for invalid YAML', async () => {
            // TODO: part-unit-fs-plan-read-bad-yaml - Test behavior with a malformed YAML file.
            // INSTRUCTIONS:
            // 1. Write a string with invalid YAML syntax to a file.
            // 2. Call `readPlan()` with the path to that file.
            // 3. Assert that the call rejects with a YAML-specific parsing error.
          });
      =======
          it('should correctly count plans across different statuses and phases', async () => {
            await fs.mkdir('.nocaflow/initialization/plans/todo', { recursive: true });
            await fs.mkdir('.nocaflow/initialization/plans/doing', { recursive: true });
            await fs.mkdir('.nocaflow/development/plans/done', { recursive: true });

            await fs.writeFile('.nocaflow/initialization/plans/todo/a.yml', '');
            await fs.writeFile('.nocaflow/initialization/plans/todo/b.yml', '');
            await fs.writeFile('.nocaflow/initialization/plans/doing/c.yml', '');
            await fs.writeFile('.nocaflow/development/plans/done/d.yml', '');

            const stats = await getPhaseStats();

            expect(stats.initialization.todo).toBe(2);
            expect(stats.initialization.doing).toBe(1);
            expect(stats.initialization.done).toBe(0);
            expect(stats.initialization.total).toBe(3);

            expect(stats.development.done).toBe(1);
            expect(stats.development.total).toBe(1);
          });

          it('should return all zeros for an empty directory structure', async () => {
            await fs.mkdir('.nocaflow/initialization/plans', { recursive: true });
            await fs.mkdir('.nocaflow/development/plans', { recursive: true });

            const stats = await getPhaseStats();

            expect(stats.initialization.total).toBe(0);
            expect(stats.development.total).toBe(0);
          });

          it('should handle missing status subdirectories gracefully', async () => {
            await fs.mkdir('.nocaflow/initialization/plans/todo', { recursive: true });
            await fs.writeFile('.nocaflow/initialization/plans/todo/a.yml', '');

            const stats = await getPhaseStats();

            expect(stats.initialization.todo).toBe(1);
            expect(stats.initialization.doing).toBe(0);
            expect(stats.initialization.done).toBe(0);
            expect(stats.initialization.total).toBe(1);
          });

          it('should handle a missing phase directory gracefully', async () => {
            await fs.mkdir('.nocaflow/initialization/plans/todo', { recursive: true });
            await fs.writeFile('.nocaflow/initialization/plans/todo/a.yml', '');

            const stats = await getPhaseStats();

            expect(stats.initialization.total).toBe(1);
            expect(stats.development.total).toBe(0);
          });

          it('should ignore non-YAML files', async () => {
            await fs.mkdir('.nocaflow/development/plans/todo', { recursive: true });
            await fs.writeFile('.nocaflow/development/plans/todo/plan1.yml', '');
            await fs.writeFile('.nocaflow/development/plans/todo/notes.txt', '');

            const stats = await getPhaseStats();

            expect(stats.development.todo).toBe(1);
            expect(stats.development.total).toBe(1);
          });
        });

        describe('getFailedReports', () => {
          it('should only return reports within the lookback period', async () => {
            const reportDir = '.nocaflow/initialization/plans/failed/report';
            await fs.mkdir(reportDir, { recursive: true });

            const recentReportPath = path.join(reportDir, 'plan1.partA.report.md');
            const oldReportPath = path.join(reportDir, 'plan2.partB.report.md');
            await fs.writeFile(recentReportPath, '## Summary\n\nRecent failure.');
            await fs.writeFile(oldReportPath, '## Summary\n\nOld failure.');

            const twoDaysAgo = new Date();
            twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
            await fs.utimes(oldReportPath, twoDaysAgo, twoDaysAgo);

            const reports = await getFailedReports(24);

            expect(reports).toHaveLength(1);
            expect(reports[0].planId).toBe('plan1');
          });

          it('should correctly parse report details from filename and content', async () => {
            const reportDir = '.nocaflow/development/plans/failed/report';
            await fs.mkdir(reportDir, { recursive: true });
            const reportPath = path.join(reportDir, 'plan1.partA.report.md');
            await fs.writeFile(reportPath, '## Summary\n\nThis is the reason.');

            const reports = await getFailedReports(1);

            expect(reports).toHaveLength(1);
            expect(reports[0].planId).toBe('plan1');
            expect(reports[0].partId).toBe('partA');
            expect(reports[0].reason).toBe('This is the reason.');
            expect(reports[0].reportPath).toBe(reportPath);
          });

          it('should return an empty array if the report directory does not exist', async () => {
            const reports = await getFailedReports(24);
            expect(reports).toEqual([]);
          });

          it('should gracefully handle malformed report filenames', async () => {
            const reportDir = '.nocaflow/development/plans/failed/report';
            await fs.mkdir(reportDir, { recursive: true });
            const reportPath = path.join(reportDir, 'malformed.report.md');
            await fs.writeFile(reportPath, '## Summary\n\nReason.');

            const reports = await getFailedReports(1);

            expect(reports).toHaveLength(1);
            expect(reports[0].planId).toBe('malformed');
            expect(reports[0].partId).toBeUndefined();
          });

          it('should ignore non-markdown report files', async () => {
            const reportDir = '.nocaflow/initialization/plans/failed/report';
            await fs.mkdir(reportDir, { recursive: true });
            await fs.writeFile(path.join(reportDir, 'plan1.partA.report.md'), '## Summary\n\nReport');
            await fs.writeFile(path.join(reportDir, 'notes.txt'), 'some notes');

            const reports = await getFailedReports(1);
            expect(reports).toHaveLength(1);
            expect(reports[0].planId).toBe('plan1');
          });
        });

        describe('readPlan', () => {
          it('should parse a valid plan file', async () => {
            const planContent = `
      plan:
        id: 'test-plan'
        status: 'todo'
        title: 'Test Plan'
        introduction: 'Intro'
        parts: []
        conclusion: 'Conclusion'
        context_files: { compact: [], medium: [], extended: [] }
      `;
            await fs.writeFile('plan.yml', planContent);
            const plan = await readPlan('plan.yml');
            expect(plan.plan.id).toBe('test-plan');
            expect(plan.plan.title).toBe('Test Plan');
          });

          it('should throw an error for a non-existent file', async () => {
            await expect(readPlan('non-existent-plan.yml')).rejects.toThrow();
          });

          it('should throw an error for invalid YAML', async () => {
            await fs.writeFile('bad-plan.yml', 'key: value\n  bad-indent');
            await expect(readPlan('bad-plan.yml')).rejects.toThrow();
          });
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/utils/logs.test.ts
    content: |
      <<<<<<< SEARCH
        it('should aggregate logs from all phase directories', async () => {
          // TODO: part-unit-logs-aggregate - Test reading from both initialization and development log dirs.
          // INSTRUCTIONS:
          // 1. Create log directories for both phases, e.g., `.nocaflow/initialization/agent-log`.
          // 2. Create a log file in each directory with valid log entries.
          // 3. Call `getRecentLogs(10)`.
          // 4. Assert that the result contains log entries from both files.
        });

        it('should return the correct number of recent, sorted log entries', async () => {
          // TODO: part-unit-logs-limit-sort - Test the limit and sorting logic.
          // INSTRUCTIONS:
          // 1. Create a single log file.
          // 2. Write several (e.g., 10) valid log entries with timestamps that are *out of order*.
          // 3. Call `getRecentLogs(5)`.
          // 4. Assert that the result array has a length of 5.
          // 5. Assert that the entries in the array are sorted by timestamp in descending order.
        });

        it('should correctly parse valid log lines and skip invalid ones', async () => {
          // TODO: part-unit-logs-parse - Test the parsing logic for valid and invalid lines.
          // INSTRUCTIONS:
          // 1. Create a log file containing a mix of correctly formatted and malformed log lines.
          // 2. Call `getRecentLogs(10)`.
          // 3. Assert that the result only contains entries corresponding to the valid lines.
        });

        it('should correctly parse log lines with varied content', async () => {
          // TODO: part-unit-logs-parse-varied - Test the regex against varied but valid content.
          // INSTRUCTIONS:
          // 1. Create a log file with entries having:
          //    - agentId with dashes or special characters (e.g., `scaffolder-123`).
          //    - planId with dots or dashes.
          //    - message content with special characters.
          // 2. Call `getRecentLogs(10)`.
          // 3. Assert that all entries are parsed correctly with their full, un-truncated content.
        });

        it('should handle empty log files gracefully', async () => {
          // TODO: part-unit-logs-empty-file - Test behavior with empty log files.
          // INSTRUCTIONS:
          // 1. Create a log directory and an empty `agent.log` file inside it.
          // 2. Call `getRecentLogs(5)`.
          // 3. Assert that the result is an empty array and no error was thrown.
        });

        it('should return an empty array if log directories are missing', async () => {
          // TODO: part-unit-logs-no-dir - Test behavior when log directories do not exist.
          // INSTRUCTIONS:
          // 1. Do not create any `.nocaflow` directories.
          // 2. Call `getRecentLogs(5)`.
          // 3. Assert that the result is an empty array.
        });

        it('should ignore files that do not end with .log', async () => {
          // TODO: part-unit-logs-ignore-files - Test that non-log files are not read.
          // INSTRUCTIONS:
          // 1. Create a log directory.
          // 2. Create `agent.log` with one entry and `agent.log.bak` with another entry.
          // 3. Call `getRecentLogs(5)`.
          // 4. Assert that the result contains only one entry (from `agent.log`).
        });
      =======
        it('should aggregate logs from all phase directories', async () => {
          const initLogDir = '.nocaflow/initialization/agent-log';
          const devLogDir = '.nocaflow/development/agent-log';
          await fs.mkdir(initLogDir, { recursive: true });
          await fs.mkdir(devLogDir, { recursive: true });

          const log1 = `2023-01-01T10:00:00.000Z [DONE|INIT|agent1] plan:planA - Init log`;
          const log2 = `2023-01-01T11:00:00.000Z [INFO|DEV|agent2] plan:planB - Dev log`;
          await fs.writeFile(path.join(initLogDir, 'init.log'), log1);
          await fs.writeFile(path.join(devLogDir, 'dev.log'), log2);

          const logs = await getRecentLogs(10);
          expect(logs).toHaveLength(2);
          expect(logs.some(l => l.message === 'Init log')).toBe(true);
          expect(logs.some(l => l.message === 'Dev log')).toBe(true);
        });

        it('should return the correct number of recent, sorted log entries', async () => {
          const logDir = '.nocaflow/initialization/agent-log';
          await fs.mkdir(logDir, { recursive: true });
          const logContent = [
            `2023-01-01T10:00:00.000Z [DONE|INIT|a] plan:p1 - msg1`,
            `2023-01-01T12:00:00.000Z [DONE|INIT|b] plan:p2 - msg3`,
            `2023-01-01T11:00:00.000Z [DONE|INIT|c] plan:p3 - msg2`,
            `2023-01-01T14:00:00.000Z [DONE|INIT|d] plan:p4 - msg5`,
            `2023-01-01T13:00:00.000Z [DONE|INIT|e] plan:p5 - msg4`,
          ].join('\n');
          await fs.writeFile(path.join(logDir, 'test.log'), logContent);

          const logs = await getRecentLogs(3);
          expect(logs).toHaveLength(3);
          expect(logs[0].message).toBe('msg5');
          expect(logs[1].message).toBe('msg4');
          expect(logs[2].message).toBe('msg3');
        });

        it('should correctly parse valid log lines and skip invalid ones', async () => {
          const logDir = '.nocaflow/initialization/agent-log';
          await fs.mkdir(logDir, { recursive: true });
          const logContent = [
            `2023-01-01T10:00:00.000Z [DONE|INIT|agent1] plan:planA - Valid message`,
            `This is a malformed line`,
            `2023-01-01T11:00:00.000Z [FAIL|QA|qa-agent] plan:planB - Another valid one`,
            `[FAIL|QA|qa-agent] plan:planB - Missing timestamp`,
          ].join('\n');
          await fs.writeFile(path.join(logDir, 'mixed.log'), logContent);

          const logs = await getRecentLogs(10);
          expect(logs).toHaveLength(2);
          expect(logs[0].message).toBe('Another valid one');
          expect(logs[1].message).toBe('Valid message');
        });

        it('should correctly parse log lines with varied content', async () => {
          const logDir = '.nocaflow/development/agent-log';
          await fs.mkdir(logDir, { recursive: true });
          const logContent = `2023-01-01T10:00:00.000Z [INFO|DEV|agent-with-dashes_123] plan:plan.id.with.dots - Message with | and other chars`;
          await fs.writeFile(path.join(logDir, 'varied.log'), logContent);

          const logs = await getRecentLogs(1);
          expect(logs).toHaveLength(1);
          expect(logs[0].agentId).toBe('agent-with-dashes_123');
          expect(logs[0].planId).toBe('plan.id.with.dots');
          expect(logs[0].message).toBe('Message with | and other chars');
        });

        it('should handle empty log files gracefully', async () => {
          const logDir = '.nocaflow/initialization/agent-log';
          await fs.mkdir(logDir, { recursive: true });
          await fs.writeFile(path.join(logDir, 'empty.log'), '');

          const logs = await getRecentLogs(5);
          expect(logs).toEqual([]);
        });

        it('should return an empty array if log directories are missing', async () => {
          const logs = await getRecentLogs(5);
          expect(logs).toEqual([]);
        });

        it('should ignore files that do not end with .log', async () => {
          const logDir = '.nocaflow/initialization/agent-log';
          await fs.mkdir(logDir, { recursive: true });
          const logContent = `2023-01-01T10:00:00.000Z [DONE|INIT|agent1] plan:planA - Real log`;
          const bakContent = `2023-01-01T11:00:00.000Z [DONE|INIT|agent2] plan:planB - Backup log`;
          await fs.writeFile(path.join(logDir, 'agent.log'), logContent);
          await fs.writeFile(path.join(logDir, 'agent.log.bak'), bakContent);

          const logs = await getRecentLogs(5);
          expect(logs).toHaveLength(1);
          expect(logs[0].message).toBe('Real log');
        });
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/utils/shell.test.ts
    content: |
      <<<<<<< SEARCH
        describe('getActiveAgents', () => {
          it('should parse all types of agent sessions and ignore non-agent sessions', async () => {
            // TODO: part-unit-shell-parse-all - Test parsing of various valid tmux session names.
            // INSTRUCTIONS:
            // 1. Define a mock `stdout` string from `tmux ls` containing lines for init, dev, scaffold, and qa agents, plus a non-agent session.
            // 2. Mock `mockedExec` to return this `stdout` string.
            // 3. Call `getActiveAgents()`.
            // 4. Assert that the result array contains the correct number of agents (ignoring the non-agent session).
            // 5. Assert that each agent object has correctly parsed details (phase, planId, etc.).
          });

          it('should ignore session names that are similar to but not valid agent sessions', async () => {
            // TODO: part-unit-shell-parse-similar - Test that tricky but invalid names are ignored.
            // INSTRUCTIONS:
            // 1. Define mock `stdout` with sessions like `init-`, `dev-scaffold-123`, `qa`, `my-init-session`.
            // 2. Mock `mockedExec` to return this stdout.
            // 3. Call `getActiveAgents()`.
            // 4. Assert that the result is an empty array.
          });

          it('should return an empty array when there are no tmux sessions', async () => {
            // TODO: part-unit-shell-parse-empty - Test with empty output from tmux.
            // INSTRUCTIONS:
            // 1. Mock `mockedExec` to return an empty string for `stdout`.
            // 2. Call `getActiveAgents()`.
            // 3. Assert that the result is an empty array.
          });

          it('should return an empty array if the tmux command fails', async () => {
            // TODO: part-unit-shell-parse-fail - Test when the `exec` call fails.
            // INSTRUCTIONS:
            // 1. Mock `mockedExec` to simulate an error (e.g., have the callback pass an Error object).
            // 2. Call `getActiveAgents()`.
            // 3. Assert that the function catches the error and returns an empty array.
          });

          it('should correctly calculate agent runtime', async () => {
            // TODO: part-unit-shell-parse-runtime - Test the relative time calculation.
            // INSTRUCTIONS:
            // 1. Use `jest.spyOn(Date, 'now')` or `jest.useFakeTimers` to control the current time.
            // 2. Create a mock `stdout` with a session activity timestamp that is a known duration in the past (e.g., 5 minutes).
            // 3. Mock `mockedExec` to return this stdout.
            // 4. Call `getActiveAgents()`.
            // 5. Assert that the `runtime` string for the agent is the expected relative time (e.g., "5 minutes").
          });
        });
      =======
        describe('getActiveAgents', () => {
          it('should parse all types of agent sessions and ignore non-agent sessions', async () => {
            const now = dayjs().unix();
            const stdout = [
              `init-part123 111 ${now}`,
              `dev-part456 222 ${now}`,
              `init-scaffold-plan789 333 ${now}`,
              `qa-planABC 444 ${now}`,
              `my-random-session 555 ${now}`,
            ].join('\n');
            mockedExec.mockImplementation((_cmd, callback) => callback(null, { stdout, stderr: '' }));

            const agents = await getActiveAgents();
            expect(agents).toHaveLength(4);

            expect(agents).toContainEqual(expect.objectContaining({ phase: 'INIT', partId: 'part123', pid: '111' }));
            expect(agents).toContainEqual(expect.objectContaining({ phase: 'DEV', partId: 'part456', pid: '222' }));
            expect(agents).toContainEqual(expect.objectContaining({ phase: 'SCAF', planId: 'plan789', pid: '333' }));
            expect(agents).toContainEqual(expect.objectContaining({ phase: 'QA', planId: 'planABC', pid: '444' }));
          });

          it('should ignore session names that are similar to but not valid agent sessions', async () => {
            const now = dayjs().unix();
            const stdout = [
              `init- 111 ${now}`,
              `dev-scaffold-123 222 ${now}`,
              `qa 333 ${now}`,
              `my-init-session 444 ${now}`,
            ].join('\n');
            mockedExec.mockImplementation((_cmd, callback) => callback(null, { stdout, stderr: '' }));

            const agents = await getActiveAgents();
            expect(agents).toEqual([]);
          });

          it('should return an empty array when there are no tmux sessions', async () => {
            mockedExec.mockImplementation((_cmd, callback) => callback(null, { stdout: '', stderr: '' }));
            const agents = await getActiveAgents();
            expect(agents).toEqual([]);
          });

          it('should return an empty array if the tmux command fails', async () => {
            mockedExec.mockImplementation((_cmd, callback) => callback(new Error('tmux failed'), { stdout: '', stderr: '' }));
            const agents = await getActiveAgents();
            expect(agents).toEqual([]);
          });

          it('should correctly calculate agent runtime', async () => {
            jest.useFakeTimers().setSystemTime(new Date('2023-01-01T12:00:00Z'));

            const fiveMinutesAgo = dayjs('2023-01-01T11:55:00Z').unix();
            const stdout = `dev-part123 111 ${fiveMinutesAgo}`;
            mockedExec.mockImplementation((_cmd, callback) => callback(null, { stdout, stderr: '' }));

            const agents = await getActiveAgents();

            expect(agents).toHaveLength(1);
            // dayjs relative time can be "a few seconds", "a minute", etc. so we check for a known value.
            // "5 minutes" is the expected output.
            expect(agents[0].runtime).toBe('5 minutes');

            jest.useRealTimers();
          });
        });
      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  test/unit/utils/logs.test.ts: |-
    import { getRecentLogs } from '../../../src/utils/logs';
    import { setupTestDirectory } from '../../test.util';
    import fs from 'fs/promises';
    import path from 'path';

    describe('unit/utils/logs', () => {
      let cleanup: () => Promise<void>;

      beforeEach(async () => {
        // TODO: part-unit-logs-setup - Set up a clean directory for each test.
        // INSTRUCTIONS:
        // 1. Use `setupTestDirectory()` to create a temporary, isolated directory.
        const { cleanup: c } = await setupTestDirectory();
        cleanup = c;
      });

      afterEach(async () => {
        // TODO: part-unit-logs-cleanup - Clean up the temporary directory.
        // INSTRUCTIONS:
        // 1. Call the `cleanup()` function.
        await cleanup();
      });

      it('should aggregate logs from all phase directories', async () => {
        // TODO: part-unit-logs-aggregate - Test reading from both initialization and development log dirs.
        // INSTRUCTIONS:
        // 1. Create log directories for both phases, e.g., `.nocaflow/initialization/agent-log`.
        // 2. Create a log file in each directory with valid log entries.
        // 3. Call `getRecentLogs(10)`.
        // 4. Assert that the result contains log entries from both files.
      });

      it('should return the correct number of recent, sorted log entries', async () => {
        // TODO: part-unit-logs-limit-sort - Test the limit and sorting logic.
        // INSTRUCTIONS:
        // 1. Create a single log file.
        // 2. Write several (e.g., 10) valid log entries with timestamps that are *out of order*.
        // 3. Call `getRecentLogs(5)`.
        // 4. Assert that the result array has a length of 5.
        // 5. Assert that the entries in the array are sorted by timestamp in descending order.
      });

      it('should correctly parse valid log lines and skip invalid ones', async () => {
        // TODO: part-unit-logs-parse - Test the parsing logic for valid and invalid lines.
        // INSTRUCTIONS:
        // 1. Create a log file containing a mix of correctly formatted and malformed log lines.
        // 2. Call `getRecentLogs(10)`.
        // 3. Assert that the result only contains entries corresponding to the valid lines.
      });

      it('should correctly parse log lines with varied content', async () => {
        // TODO: part-unit-logs-parse-varied - Test the regex against varied but valid content.
        // INSTRUCTIONS:
        // 1. Create a log file with entries having:
        //    - agentId with dashes or special characters (e.g., `scaffolder-123`).
        //    - planId with dots or dashes.
        //    - message content with special characters.
        // 2. Call `getRecentLogs(10)`.
        // 3. Assert that all entries are parsed correctly with their full, un-truncated content.
      });

      it('should handle empty log files gracefully', async () => {
        // TODO: part-unit-logs-empty-file - Test behavior with empty log files.
        // INSTRUCTIONS:
        // 1. Create a log directory and an empty `agent.log` file inside it.
        // 2. Call `getRecentLogs(5)`.
        // 3. Assert that the result is an empty array and no error was thrown.
      });

      it('should return an empty array if log directories are missing', async () => {
        // TODO: part-unit-logs-no-dir - Test behavior when log directories do not exist.
        // INSTRUCTIONS:
        // 1. Do not create any `.nocaflow` directories.
        // 2. Call `getRecentLogs(5)`.
        // 3. Assert that the result is an empty array.
      });

      it('should ignore files that do not end with .log', async () => {
        // TODO: part-unit-logs-ignore-files - Test that non-log files are not read.
        // INSTRUCTIONS:
        // 1. Create a log directory.
        // 2. Create `agent.log` with one entry and `agent.log.bak` with another entry.
        // 3. Call `getRecentLogs(5)`.
        // 4. Assert that the result contains only one entry (from `agent.log`).
      });
    });
  test/unit/utils/fs.test.ts: >-
    import { getPhaseStats, getFailedReports, readPlan } from
    '../../../src/utils/fs';

    import { setupTestDirectory } from '../../test.util';

    import fs from 'fs/promises';

    import path from 'path';


    describe('unit/utils/fs', () => {
      let cleanup: () => Promise<void>;

      beforeEach(async () => {
        // TODO: part-unit-fs-setup - Use the test utility to create a clean, isolated directory.
        // INSTRUCTIONS:
        // 1. Call `setupTestDirectory()` to get the cleanup function.
        const { cleanup: c } = await setupTestDirectory();
        cleanup = c;
      });

      afterEach(async () => {
        // TODO: part-unit-fs-cleanup - Use the cleanup function from the test utility.
        // INSTRUCTIONS:
        // 1. Call the `cleanup()` function to restore the CWD and remove the temporary directory.
        await cleanup();
      });

      describe('getPhaseStats', () => {
        it('should correctly count plans across different statuses and phases', async () => {
          // TODO: part-unit-fs-stats-count - Test plan counting with a populated directory structure.
          // INSTRUCTIONS:
          // 1. Create a `.nocaflow` directory structure.
          //    - e.g., `fs.mkdir('.nocaflow/initialization/plans/todo', { recursive: true })`
          // 2. Create dummy plan files in various status directories.
          //    - e.g., `fs.writeFile('.nocaflow/initialization/plans/todo/a.yml', '')`
          //    - e.g., `fs.writeFile('.nocaflow/development/plans/done/b.yml', '')`
          // 3. Call `getPhaseStats()`.
          // 4. Assert that the returned stats object accurately reflects the file counts.
        });

        it('should return all zeros for an empty directory structure', async () => {
          // TODO: part-unit-fs-stats-empty - Test plan counting with an empty structure.
          // INSTRUCTIONS:
          // 1. Create the top-level `.nocaflow` directory and phase directories, but leave plan folders empty.
          // 2. Call `getPhaseStats()`.
          // 3. Assert that all counts in the returned stats object are 0.
        });

        it('should handle missing status subdirectories gracefully', async () => {
          // TODO: part-unit-fs-stats-missing-subdir - Test plan counting with some status dirs missing.
          // INSTRUCTIONS:
          // 1. Create a structure like `.nocaflow/initialization/plans/` but only create a `todo` subdirectory, not `doing`, `done`, etc.
          // 2. Create a plan file in the `todo` directory.
          // 3. Call `getPhaseStats()`.
          // 4. Assert that the stats for `initialization` show `todo: 1` and `doing: 0`, `done: 0`, etc., without throwing an error.
        });

        it('should handle a missing phase directory gracefully', async () => {
          // TODO: part-unit-fs-stats-missing-phase-dir - Test with a whole phase directory missing.
          // INSTRUCTIONS:
          // 1. Create a structure for `.nocaflow/initialization` with some plans.
          // 2. Do NOT create the `.nocaflow/development` directory at all.
          // 3. Call `getPhaseStats()`.
          // 4. Assert that the stats for `initialization` are correct.
          // 5. Assert that the stats for `development` are all zero and no error was thrown.
        });

        it('should ignore non-YAML files', async () => {
          // TODO: part-unit-fs-stats-ignore-files - Test that non-plan files are not counted.
          // INSTRUCTIONS:
          // 1. Create a `.nocaflow/development/plans/todo` directory.
          // 2. Create `plan1.yml` and `notes.txt` in that directory.
          // 3. Call `getPhaseStats()`.
          // 4. Assert that the `todo` count for `development` is 1, not 2.
        });
      });

      describe('getFailedReports', () => {
        it('should only return reports within the lookback period', async () => {
          // TODO: part-unit-fs-reports-time - Test that only recent reports are returned.
          // INSTRUCTIONS:
          // 1. Create the failed report directory structure.
          // 2. Create two report files: one recent, one old.
          // 3. Use `fs.utimes` or a similar method to modify the `mtime` of the old file to be outside the lookback window.
          // 4. Call `getFailedReports(24)` (for 24 hours).
          // 5. Assert that the result array contains only the recent report.
        });

        it('should correctly parse report details from filename and content', async () => {
          // TODO: part-unit-fs-reports-parse - Test parsing of report details.
          // INSTRUCTIONS:
          // 1. Create a report file named `plan1.partA.report.md`.
          // 2. Write markdown content to it, including a "## Summary" section.
          // 3. Call `getFailedReports(1)`.
          // 4. Assert that the returned `FailedReport` object has `planId: 'plan1'`, `partId: 'partA'`, and the correct `reason` text.
        });

        it('should return an empty array if the report directory does not exist', async () => {
          // TODO: part-unit-fs-reports-no-dir - Test behavior with no report directory.
          // INSTRUCTIONS:
          // 1. Do not create any failed report directories.
          // 2. Call `getFailedReports(24)`.
          // 3. Assert that the result is an empty array.
        });

        it('should gracefully handle malformed report filenames', async () => {
          // TODO: part-unit-fs-reports-bad-name - Test parsing of malformed report names.
          // INSTRUCTIONS:
          // 1. Create a report file named `malformed.report.md` (missing partId).
          // 2. Call `getFailedReports(1)`.
          // 3. Assert that the returned object has sensible defaults (e.g., `planId: 'malformed'`, `partId: undefined`).
        });

        it('should ignore non-markdown report files', async () => {
          // TODO: part-unit-fs-reports-ignore-files - Test that non-report files are ignored.
          // INSTRUCTIONS:
          // 1. Create a failed report directory.
          // 2. Create `plan1.partA.report.md` and `notes.txt`.
          // 3. Call `getFailedReports(1)`.
          // 4. Assert that the result array has a length of 1, containing only the report.
        });
      });

      describe('readPlan', () => {
        it('should parse a valid plan file', async () => {
          // TODO: part-unit-fs-plan-read-success - Test reading a valid YAML plan.
          // INSTRUCTIONS:
          // 1. Define a valid plan object and serialize it to a YAML string.
          // 2. Write this string to a file, e.g., `plan.yml`.
          // 3. Call `readPlan('plan.yml')`.
          // 4. Assert that the returned object deeply equals the original plan object.
        });

        it('should throw an error for a non-existent file', async () => {
          // TODO: part-unit-fs-plan-read-no-file - Test behavior when file is missing.
          // INSTRUCTIONS:
          // 1. Call `readPlan('non-existent-plan.yml')`.
          // 2. Assert that the call rejects with an error (e.g., using `expect(...).rejects.toThrow()`).
        });

        it('should throw an error for invalid YAML', async () => {
          // TODO: part-unit-fs-plan-read-bad-yaml - Test behavior with a malformed YAML file.
          // INSTRUCTIONS:
          // 1. Write a string with invalid YAML syntax to a file.
          // 2. Call `readPlan()` with the path to that file.
          // 3. Assert that the call rejects with a YAML-specific parsing error.
        });
      });
    });
  test/unit/utils/shell.test.ts: >-
    import { getActiveAgents } from '../../../src/utils/shell';

    import { exec } from 'child_process';

    import dayjs from 'dayjs';

    import relativeTime from 'dayjs/plugin/relativeTime';


    // Note: This is an exception to the "no mock" rule. `tmux` is an external
    system

    // dependency, not internal application logic. Mocking `exec` is the only
    reliable

    // way to test the parsing logic in a CI environment without requiring
    `tmux` to be running.

    jest.mock('child_process');

    const mockedExec = exec as jest.Mock;

    dayjs.extend(relativeTime);


    describe('unit/utils/shell', () => {
      afterEach(() => {
        jest.clearAllMocks();
      });

      describe('getActiveAgents', () => {
        it('should parse all types of agent sessions and ignore non-agent sessions', async () => {
          // TODO: part-unit-shell-parse-all - Test parsing of various valid tmux session names.
          // INSTRUCTIONS:
          // 1. Define a mock `stdout` string from `tmux ls` containing lines for init, dev, scaffold, and qa agents, plus a non-agent session.
          // 2. Mock `mockedExec` to return this `stdout` string.
          // 3. Call `getActiveAgents()`.
          // 4. Assert that the result array contains the correct number of agents (ignoring the non-agent session).
          // 5. Assert that each agent object has correctly parsed details (phase, planId, etc.).
        });

        it('should ignore session names that are similar to but not valid agent sessions', async () => {
          // TODO: part-unit-shell-parse-similar - Test that tricky but invalid names are ignored.
          // INSTRUCTIONS:
          // 1. Define mock `stdout` with sessions like `init-`, `dev-scaffold-123`, `qa`, `my-init-session`.
          // 2. Mock `mockedExec` to return this stdout.
          // 3. Call `getActiveAgents()`.
          // 4. Assert that the result is an empty array.
        });

        it('should return an empty array when there are no tmux sessions', async () => {
          // TODO: part-unit-shell-parse-empty - Test with empty output from tmux.
          // INSTRUCTIONS:
          // 1. Mock `mockedExec` to return an empty string for `stdout`.
          // 2. Call `getActiveAgents()`.
          // 3. Assert that the result is an empty array.
        });

        it('should return an empty array if the tmux command fails', async () => {
          // TODO: part-unit-shell-parse-fail - Test when the `exec` call fails.
          // INSTRUCTIONS:
          // 1. Mock `mockedExec` to simulate an error (e.g., have the callback pass an Error object).
          // 2. Call `getActiveAgents()`.
          // 3. Assert that the function catches the error and returns an empty array.
        });

        it('should correctly calculate agent runtime', async () => {
          // TODO: part-unit-shell-parse-runtime - Test the relative time calculation.
          // INSTRUCTIONS:
          // 1. Use `jest.spyOn(Date, 'now')` or `jest.useFakeTimers` to control the current time.
          // 2. Create a mock `stdout` with a session activity timestamp that is a known duration in the past (e.g., 5 minutes).
          // 3. Mock `mockedExec` to return this stdout.
          // 4. Call `getActiveAgents()`.
          // 5. Assert that the `runtime` string for the agent is the expected relative time (e.g., "5 minutes").
        });
      });
    });
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-11-12T03:12:35.123Z'
status: committed
id: 19
