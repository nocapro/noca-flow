uuid: a69720b0-a006-4b82-824e-b530c34e06d9
projectId: noca-flow
createdAt: '2025-11-13T03:42:21.293Z'
gitCommitMsg: >-
  refactor(state): Improve data integrity and performance of state command

  Refactored the `nocaflow state` data fetchers for improved integrity, clarity,
  and performance.

  - Redefined the `AgentInfo` interface in `shell.ts` to use explicit,
    unambiguous fields (`planId`, `partId`, `type`), removing the
    confusing `id` field.
  - Updated the agent display logic in `state.ts` to provide clearer,
    more structured output based on the agent's specific type (Worker,
    Scaffolder, QA).
  - Rewrote unit tests for `shell.ts` to validate the new data model,
    ensuring correct parsing of tmux session names.
  - Optimized `getGitLog` in `git.ts` by replacing an N+1 `git show`
    loop with a single, efficient `git log` command that fetches all
    required commit data at once. This significantly improves performance.
promptSummary: >-
  The user requested a refactor of the `nocaflow state` command to improve data
  integrity and accuracy, with a focus on active agent reporting and Git log
  fetching. I have implemented these changes and updated relevant tests.
reasoning:
  - >-
    Excellent. A plan to harden observability and performance is a plan I can
    get behind. Let's execute this refactor. We'll start by solidifying the
    agent data model, then optimize the Git history retrieval.
  - '### Part 1: Refactor Active Agent Reporting'
  - >-
    First, I'll update the `AgentInfo` interface in `src/utils/shell.ts` to be
    explicit about `planId` and `partId`. The ambiguous `id` field is a source
    of confusion and is being removed in favor of clear, distinct properties.
    The parsing logic in `getActiveAgents` will be updated to populate this new
    structure correctly.
  - >-
    Next, I'll adjust the `state` command's output to use this new, richer data
    structure. The display will now be more explicit about agent types (Worker,
    Scaffolder, QA) and their associated plan or part IDs.
  - >-
    To lock in these changes, I'll update the unit tests for `getActiveAgents`.
    The assertions are modified to validate the new `AgentInfo` shape, ensuring
    our parsing logic is correct and preventing future regressions.
  - '### Part 2: Optimize Git Log Retrieval'
  - >-
    Now, I'll eliminate the N+1 anti-pattern in `getGitLog`. I'm modifying the
    `simple-git` call to fetch the hash, refs, and the full commit message body
    in a single, efficient operation. This removes the slow, iterative `git
    show` calls.
  - >-
    This completes the refactor. The `state` command is now faster and its
    output is more precise, improving the overall integrity and observability of
    the system.
operations:
  - type: write
    path: src/utils/shell.ts
    content: >+
      --- src/utils/shell.ts

      +++ src/utils/shell.ts

      @@ -3,13 +3,15 @@
       import { platform } from './platform';
       
       export interface AgentInfo {
      -  phase: 'INIT' | 'DEV' | 'QA' | 'SCAF';

      -  id: string; // part_id, plan_id for QA/Scaffold

      -  planId: string;

      -  partId: string; // Can be 'scaffold' or 'qa'

      +  sessionName: string;

      +  type: 'WORKER' | 'SCAFFOLDER' | 'QA';

      +  // Phase is known for workers and scaffolders, but not for QA agents
      from session name alone.

      +  phase: 'INIT' | 'DEV' | null;

      +  planId: string | null;

      +  partId: string | null;
         runtime: string;
         pid: string;
       }
       
       dayjs.extend(relativeTime);
       
      @@ -29,28 +31,39 @@
             if ((match = sessionName.match(/^init-scaffold-(.+)/))) {
               const planId = match[1];
               agents.push({
      -          phase: 'SCAF',

      -          id: planId,

      +          sessionName,

      +          type: 'SCAFFOLDER',

      +          phase: 'INIT',
                 planId,
                 partId: 'scaffold',
                 runtime,
                 pid,
               });
             } else if ((match = sessionName.match(/^qa-(.+)/))) {
               const planId = match[1];
      -        agents.push({ phase: 'QA', id: planId, planId, partId: 'qa',
      runtime, pid });

      +        agents.push({

      +          sessionName,

      +          type: 'QA',

      +          phase: null,

      +          planId,

      +          partId: 'qa',

      +          runtime,

      +          pid,

      +        });
             } else if ((match = sessionName.match(/^(init|dev)-(?!scaffold-|qa-)(.+)/))) {
               const phase = match[1].toUpperCase() as 'INIT' | 'DEV';
               const partId = match[2];
               agents.push({
      +          sessionName,

      +          type: 'WORKER',
                 phase,
      -          id: partId,

      -          planId: 'unknown', // Not available from session name

      -          partId: partId,

      +          planId: null, // Not available from session name for workers

      +          partId,
                 runtime,
                 pid,
               });
             }
           }
           return agents;
         } catch (error) {

    patchStrategy: standard-diff
  - type: write
    path: src/commands/state.ts
    content: >+
      --- src/commands/state.ts

      +++ src/commands/state.ts

      @@ -62,9 +62,26 @@
         if (activeAgents.length === 0) {
           console.log('No active agents.');
         } else {
      -    for (const agent of activeAgents) {

      -     
      console.log(`[${chalk.blue(agent.phase)}|${chalk.magenta(agent.pid)}]`.padEnd(18)
      + `id:${agent.id} (running ${agent.runtime})`);

      -    }

      +    activeAgents.forEach(agent => {

      +      let agentTypeInfo = '';

      +      let idInfo = '';

      +

      +      switch (agent.type) {

      +        case 'SCAFFOLDER':

      +          agentTypeInfo =
      `[${chalk.blue(agent.type)}|${chalk.yellow(String(agent.phase))}|${chalk.magenta(agent.pid)}]`;

      +          idInfo = `plan:${agent.planId}`;

      +          break;

      +        case 'WORKER':

      +          agentTypeInfo =
      `[${chalk.blue(agent.type)}|${chalk.yellow(String(agent.phase))}|${chalk.magenta(agent.pid)}]`;

      +          idInfo = `part:${agent.partId}`;

      +          break;

      +        case 'QA':

      +          // Phase is null for QA, so we omit it.

      +          agentTypeInfo =
      `[${chalk.blue(agent.type)}|${chalk.magenta(agent.pid)}]`;

      +          idInfo = `plan:${agent.planId}`;

      +          break;

      +      }

      +      console.log(`${agentTypeInfo.padEnd(28)} ${idInfo} (running
      ${agent.runtime})`);

      +    });
         }
       
         // Recent Agent Activity

    patchStrategy: standard-diff
  - type: write
    path: test/unit/utils/shell.test.ts
    content: >+
      --- test/unit/utils/shell.test.ts

      +++ test/unit/utils/shell.test.ts

      @@ -35,28 +35,42 @@
           it('should parse all types of agent sessions and ignore non-agent sessions', async () => {
             const agents = await getActiveAgents();
             // Filter for agents created in this specific test run to ensure isolation
      -      const testAgents = agents.filter(

      -        a => a.partId.endsWith(testId) || a.planId.endsWith(testId),

      -      );

      +      const testAgents = agents.filter(a =>
      a.sessionName.endsWith(testId));
       
             expect(testAgents).toHaveLength(4);
       
             expect(testAgents).toContainEqual(
      -        expect.objectContaining({ phase: 'INIT', partId:
      `part123-${testId}` }),

      +        expect.objectContaining({

      +          type: 'WORKER',

      +          phase: 'INIT',

      +          partId: `part123-${testId}`,

      +          planId: null,

      +        }),
             );
             expect(testAgents).toContainEqual(
      -        expect.objectContaining({ phase: 'DEV', partId:
      `part456-${testId}` }),

      +        expect.objectContaining({

      +          type: 'WORKER',

      +          phase: 'DEV',

      +          partId: `part456-${testId}`,

      +          planId: null,

      +        }),
             );
             expect(testAgents).toContainEqual(
      -        expect.objectContaining({ phase: 'SCAF', planId:
      `plan789-${testId}` }),

      +        expect.objectContaining({

      +          type: 'SCAFFOLDER',

      +          phase: 'INIT',

      +          planId: `plan789-${testId}`,

      +          partId: 'scaffold',

      +        }),
             );
             expect(testAgents).toContainEqual(
      -        expect.objectContaining({ phase: 'QA', planId:
      `planABC-${testId}` }),

      +        expect.objectContaining({

      +          type: 'QA',

      +          phase: null,

      +          planId: `planABC-${testId}`,

      +          partId: 'qa',

      +        }),
             );
           });
       
      @@ ... @@
           });
       
           it('should correctly calculate agent runtime', async () => {
             const agents = await getActiveAgents();
      -      const devAgent = agents.find(a => a.partId ===
      `part456-${testId}`);

      +      const devAgent = agents.find(

      +        a => a.sessionName === `dev-part456-${testId}`,

      +      );
             expect(devAgent).toBeDefined();
             // The runtime is short and non-deterministic, just check it exists.
             expect(devAgent?.runtime).toContain('a few seconds');

    patchStrategy: standard-diff
  - type: write
    path: src/utils/git.ts
    content: >+
      --- src/utils/git.ts

      +++ src/utils/git.ts

      @@ -48,7 +48,7 @@
           const isRepo = await git.checkIsRepo();
           if (!isRepo) return [];
       
      -    const worktrees = await getWorktreeList();

      +    const worktrees = await getWorktreeList(); // for mapping branch to
      worktree name
           const worktreeMap = new Map<string, string>();
           for (const wt of worktrees) {
             const branchNameMatch = wt.branch.match(/refs\/heads\/(.*)/);
      @@ -60,28 +60,25 @@
             }
           }
       
      -    const logResult = await git.log({ '--all': null, maxCount: limit,
      format: { hash: '%H', refs: '%d' } });

      +    const logResult = await git.log({

      +      '--all': null,

      +      maxCount: limit,

      +      format: { hash: '%H', refs: '%d', message: '%B' }, // %B gets the
      full commit message body

      +    });

      +
           if (!logResult.all || logResult.total === 0) return [];
       
      -    const commits: GitCommit[] = [];

      -    for (const commit of logResult.all) {

      -      const fullMessageResult = await git.raw(['show', '--format=%B',
      '--no-patch', commit.hash]);

      -      const fullMessage = fullMessageResult.trim();

      -

      +    const commits = logResult.all.map(commit => {
             let worktree: string | null = null;
             // commit.refs is like ' (HEAD -> my-feature, origin/my-feature)'
             for (const branchName of worktreeMap.keys()) {
               if (commit.refs.includes(branchName)) {
                 worktree = worktreeMap.get(branchName) || null;
                 break;
               }
             }
       
      -      commits.push({

      +      return {
               hash: commit.hash,
               worktree,
      -        message: fullMessage,

      -      });

      -    }

      +        message: commit.message.trim(),

      +      };

      +    });

      +
           return commits;
         } catch (error) {
           return []; // Git not installed, not a git repo, or other error.

    patchStrategy: standard-diff
snapshot:
  src/utils/shell.ts: |-
    import dayjs from 'dayjs';
    import relativeTime from 'dayjs/plugin/relativeTime';
    import { platform } from './platform';

    export interface AgentInfo {
      phase: 'INIT' | 'DEV' | 'QA' | 'SCAF';
      id: string; // part_id, plan_id for QA/Scaffold
      planId: string;
      partId: string; // Can be 'scaffold' or 'qa'
      runtime: string;
      pid: string;
    }

    dayjs.extend(relativeTime);

    /**
     * @description Lists active tmux sessions and parses them to find agent info.
     * @returns A list of active agents.
     */
    export const getActiveAgents = async (): Promise<AgentInfo[]> => {
      try {
        const { stdout } = await platform.runCommand(`tmux ls -F "#{session_name} #{pane_pid} #{session_activity}"`);
        if (!stdout) return [];

        const lines = stdout.trim().split('\n');
        const agents: AgentInfo[] = [];

        for (const line of lines) {
          const [sessionName, pid, activity] = line.split(' ');
          const runtime = dayjs().to(dayjs.unix(parseInt(activity, 10)), true);

          let match;
          if ((match = sessionName.match(/^init-scaffold-(.+)/))) {
            const planId = match[1];
            agents.push({
              phase: 'SCAF',
              id: planId,
              planId,
              partId: 'scaffold',
              runtime,
              pid,
            });
          } else if ((match = sessionName.match(/^qa-(.+)/))) {
            const planId = match[1];
            agents.push({ phase: 'QA', id: planId, planId, partId: 'qa', runtime, pid });
          } else if ((match = sessionName.match(/^(init|dev)-(?!scaffold-|qa-)(.+)/))) {
            const phase = match[1].toUpperCase() as 'INIT' | 'DEV';
            const partId = match[2];
            agents.push({
              phase,
              id: partId,
              planId: 'unknown', // Not available from session name
              partId: partId,
              runtime,
              pid,
            });
          }
        }
        return agents;
      } catch (error) {
        return []; // Tmux likely not running or has no sessions.
      }
    };
  src/commands/state.ts: >-
    import chalk from 'chalk';

    import { getPhaseStats, PhaseStats, getFailedReports, FailedReport } from
    '../utils/fs';

    import { getActiveAgents, AgentInfo } from '../utils/shell';

    import dayjs from 'dayjs';

    import relativeTime from 'dayjs/plugin/relativeTime';

    import { getRecentLogs, LogEntry } from '../utils/logs';

    import { getGitLog, GitCommit } from '../utils/git';


    dayjs.extend(relativeTime);


    /**
     * @description Renders a progress bar.
     * @param current - The current progress value.
     * @param total - The total value for 100%.
     * @param length - The character length of the bar.
     * @returns A string representing the progress bar.
     */
    export const renderProgressBar = (current: number, total: number, length:
    number = 20): string => {
      const percent = total > 0 ? current / total : 0;
      const filledLength = Math.round(length * percent);
      const emptyLength = length - filledLength;
      const filledBar = 'â–‡'.repeat(filledLength);
      const emptyBar = '-'.repeat(emptyLength);
      const bar = `[${filledBar}${emptyBar}]`;
      const text = `(${current}/${total} plans done)`;

      return `${bar} ${text}`;
    };


    /**
     * @description Displays the full state report to the console.
     */
    export const handleStateCommand = async (_argv: Record<string, unknown>):
    Promise<void> => {
      const phaseStats: PhaseStats = await getPhaseStats();
      const activeAgents: AgentInfo[] = await getActiveAgents();
      const recentLogs: LogEntry[] = await getRecentLogs(5);
      const failedReports: FailedReport[] = await getFailedReports(24);
      const gitCommits: GitCommit[] = await getGitLog(10);
      const currentPhase = phaseStats.development?.total > 0 ? 'development' : 'initialization';

      // Header
      console.log(chalk.bold(`== nocaflow State [${dayjs().format('YYYY-MM-DD HH:mm:ss')}] ==`));
      console.log(`Current Phase: ${chalk.cyan(currentPhase)}`);
      
      // Phase Progress
      console.log(chalk.bold('\n== Phase Progress =='));
      for (const phaseName in phaseStats) {
        const stats = phaseStats[phaseName];
        const progressBar = renderProgressBar(stats.done, stats.total);
        console.log(`[${chalk.yellow(phaseName.toUpperCase())}]`.padEnd(18) + progressBar);
      }

      // Phase Stats
      console.log(chalk.bold('\n== Phase Stats (Plans) =='));
      for (const phaseName in phaseStats) {
        const stats = phaseStats[phaseName];
        if (stats.total === 0) continue;
        const statsString = `todo: ${stats.todo}, doing: ${stats.doing}, review: ${stats.review}, failed: ${stats.failed}, done: ${stats.done}`;
        console.log(`[${chalk.yellow(phaseName.toUpperCase())}]`.padEnd(18) + statsString);
      }

      // Active Agents
      console.log(chalk.bold('\n== Active Agents (tmux) =='));
      if (activeAgents.length === 0) {
        console.log('No active agents.');
      } else {
        for (const agent of activeAgents) {
          console.log(`[${chalk.blue(agent.phase)}|${chalk.magenta(agent.pid)}]`.padEnd(18) + `id:${agent.id} (running ${agent.runtime})`);
        }
      }

      // Recent Agent Activity
      console.log(chalk.bold('\n== Recent Agent Activity (last 5) =='));
      if (recentLogs.length === 0) {
        console.log('No recent activity.');
      } else {
        for (const log of recentLogs) {
          const statusColor = log.status === 'DONE' ? chalk.green : log.status === 'FAIL' ? chalk.red : chalk.gray;
          const time = dayjs(log.timestamp).fromNow();
          console.log(`${statusColor(`[${log.status}|${log.phase}|${log.agentId}]`)} plan:${log.planId} - ${log.message} (${chalk.gray(time)})`);
        }
      }

      // Stalled / Failed
      console.log(chalk.bold('\n== Stalled / Failed (last 24h) =='));
      if (failedReports.length === 0) {
        console.log('No failed reports in the last 24 hours.');
      } else {
        for (const report of failedReports) {
          console.log(`${chalk.red('[FAILED]')} plan:${report.planId} part:${report.partId} - "${report.reason}"`);
          console.log(`         Report: ${report.reportPath}`);
        }
      }

      // Recent Git Commits
      console.log(chalk.bold('\n== Recent Git Commits (all worktrees) =='));
      if (gitCommits.length === 0) {
        console.log('No recent commits.');
      } else {
        for (const commit of gitCommits) {
          const worktreeInfo = commit.worktree ? `(${chalk.cyan(commit.worktree)}) ` : '';
          console.log(`${chalk.yellow(commit.hash.slice(0, 7))} ${worktreeInfo}${commit.message}`);
        }
      }
    };
  test/unit/utils/shell.test.ts: |-
    import { getActiveAgents } from '../../../src/utils/shell';
    import { platform } from '../../../src/utils/platform';
    import dayjs from 'dayjs';
    import relativeTime from 'dayjs/plugin/relativeTime';
    import * as crypto from 'crypto';

    dayjs.extend(relativeTime);

    describe('unit/utils/shell (integration)', () => {
      const testId = crypto.randomBytes(4).toString('hex');
      const sessionNames = [
        `init-part123-${testId}`,
        `dev-part456-${testId}`,
        `init-scaffold-plan789-${testId}`,
        `qa-planABC-${testId}`,
        `my-random-session-${testId}`,
      ];

      let canRun = false;

      beforeAll(async () => {
        canRun = await platform.commandExists('tmux');
        if (!canRun) {
          console.warn('`tmux` command not found. Skipping shell integration tests.');
        }
      });

      beforeEach(async () => {
        // Start detached sessions that will self-terminate
        for (const name of sessionNames) {
          await platform.runCommand(`tmux new-session -d -s ${name} "sleep 10"`);
        }
        // Give tmux a moment to register all sessions
        await new Promise(resolve => setTimeout(resolve, 200));
      });

      afterEach(async () => {
        for (const name of sessionNames) {
          // Use `|| true` to ignore errors if session has already terminated or been killed
          await platform.runCommand(`tmux kill-session -t ${name} || true`);
        }
      });

      describe('getActiveAgents', () => {
        it('should parse all types of agent sessions and ignore non-agent sessions', async () => {
          const agents = await getActiveAgents();
          // Filter for agents created in this specific test run to ensure isolation
          const testAgents = agents.filter(
            a => a.partId.endsWith(testId) || a.planId.endsWith(testId),
          );

          expect(testAgents).toHaveLength(4);

          expect(testAgents).toContainEqual(
            expect.objectContaining({ phase: 'INIT', partId: `part123-${testId}` }),
          );
          expect(testAgents).toContainEqual(
            expect.objectContaining({ phase: 'DEV', partId: `part456-${testId}` }),
          );
          expect(testAgents).toContainEqual(
            expect.objectContaining({ phase: 'SCAF', planId: `plan789-${testId}` }),
          );
          expect(testAgents).toContainEqual(
            expect.objectContaining({ phase: 'QA', planId: `planABC-${testId}` }),
          );
        });

        it('should return an empty array if tmux has no sessions', async () => {
          // Kill the sessions from beforeEach to create an empty state
          for (const name of sessionNames) {
            await platform.runCommand(`tmux kill-session -t ${name} || true`);
          }

          const agents = await getActiveAgents();
          expect(agents).toEqual([]);
        });

        it('should correctly calculate agent runtime', async () => {
          const agents = await getActiveAgents();
          const devAgent = agents.find(a => a.partId === `part456-${testId}`);
          expect(devAgent).toBeDefined();
          // The runtime is short and non-deterministic, just check it exists.
          expect(devAgent?.runtime).toContain('a few seconds');
        });
      });
    });
  src/utils/git.ts: |-
    import { simpleGit } from 'simple-git';
    import path from 'path';
    import { platform } from './platform';

    export interface GitCommit {
      hash: string;
      worktree: string | null;
      message: string;
    }

    interface WorktreeInfo {
      path: string;
      branch: string;
      commit: string;
    }

    /**
     * Get worktree information by parsing git worktree list output
     */
    const getWorktreeList = async (): Promise<WorktreeInfo[]> => {
      try {
        const result = await platform.runCommand('git worktree list --porcelain');
        if (result.code !== 0) {
          return [];
        }

        const lines = result.stdout.trim().split('\n');
        const worktrees: WorktreeInfo[] = [];
        let currentWorktree: Partial<WorktreeInfo> = {};

        for (const line of lines) {
          if (line.startsWith('worktree ')) {
            if (currentWorktree.path) {
              worktrees.push(currentWorktree as WorktreeInfo);
            }
            currentWorktree = { path: line.substring(9) };
          } else if (line.startsWith('branch ')) {
            currentWorktree.branch = line.substring(7);
          } else if (line.startsWith('HEAD ')) {
            currentWorktree.commit = line.substring(5);
          }
        }

        if (currentWorktree.path) {
          worktrees.push(currentWorktree as WorktreeInfo);
        }

        return worktrees;
      } catch (error) {
        return [];
      }
    };

    /**
     * @description Executes 'git log' to get recent commit history across all worktrees.
     * @param limit - The maximum number of commits to return.
     * @returns A list of recent git commits.
     */
    export const getGitLog = async (limit: number): Promise<GitCommit[]> => {
      try {
        const git = simpleGit();
        const isRepo = await git.checkIsRepo();
        if (!isRepo) return [];

        const worktrees = await getWorktreeList();
        const worktreeMap = new Map<string, string>();
        for (const wt of worktrees) {
          const branchNameMatch = wt.branch.match(/refs\/heads\/(.*)/);
          if (branchNameMatch && branchNameMatch[1]) {
            const branchName = branchNameMatch[1];
            // The main worktree is not a named worktree, so we only map auxiliary ones
            if (branchName !== 'main' && branchName !== 'master') {
              worktreeMap.set(branchName, path.basename(wt.path));
            }
          }
        }

        const logResult = await git.log({ '--all': null, maxCount: limit, format: { hash: '%H', refs: '%d' } });
        if (!logResult.all || logResult.total === 0) return [];

        const commits: GitCommit[] = [];
        for (const commit of logResult.all) {
          const fullMessageResult = await git.raw(['show', '--format=%B', '--no-patch', commit.hash]);
          const fullMessage = fullMessageResult.trim();

          let worktree: string | null = null;
          // commit.refs is like ' (HEAD -> my-feature, origin/my-feature)'
          for (const branchName of worktreeMap.keys()) {
            if (commit.refs.includes(branchName)) {
              worktree = worktreeMap.get(branchName) || null;
              break;
            }
          }

          commits.push({
            hash: commit.hash,
            worktree,
            message: fullMessage,
          });
        }
        return commits;
      } catch (error) {
        return []; // Git not installed, not a git repo, or other error.
      }
    };

    /**
     * @description Checks if the current directory is a git repository.
     * @returns {Promise<boolean>}
     */
    export const isGitRepository = async (): Promise<boolean> => {
      try {
        const git = simpleGit();
        return await git.checkIsRepo();
      } catch (error) {
        return false;
      }
    };
approved: true
linesAdded: 84
linesRemoved: 32
linesDifference: 116
gitCommittedAt: null
status: committed
id: 45
