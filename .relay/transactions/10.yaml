uuid: a6259e86-8f3e-4734-b26a-9f57f5c71a39
projectId: noca-flow
createdAt: '2025-11-11T13:02:48.859Z'
gitCommitMsg: >-
  feat(testing): blueprint comprehensive test cases

  Adds detailed TODO comments and test case structures across all test suites
  (e2e, integration, and unit). This scaffolding provides a clear roadmap for AI
  agents to implement tests for core functionalities, including CLI commands,
  filesystem utilities, git interactions, logging, and shell operations. This
  work aligns with the goal of increasing test coverage and ensuring system
  reliability.
promptSummary: >-
  I need to blueprint more test cases in all test directories to increase
  coverage and align with agent protocols. The files should contain only concise
  TODO comments and signatures, not full implementations.
reasoning:
  - >-
    This is an excellent goal. By blueprinting comprehensive test cases, we
    create a clear and actionable roadmap for the AI agent swarms to follow,
    ensuring high-quality, resilient code. I will now add detailed `TODO`
    comments to the test files to scaffold this work.
  - >-
    First, I'll update the end-to-end tests for the CLI, ensuring we have a
    solid foundation for testing user-facing commands.
  - >-
    Next, I'll update the integration tests for the `init` command, providing a
    clearer blueprint for testing its core logic in isolation.
  - >-
    Now for the unit tests. I'll start with the `state` command's helper
    function, `renderProgressBar`, making the existing `TODO`s even more
    explicit.
  - >-
    I'll continue with the utility functions, starting with `fs.ts`, which is
    critical for state management.
  - >-
    Next, `git.ts` utilities for understanding the repository state, which is
    crucial for worktree-aware agents.
  - Now for `logs.ts`, which provides observability into agent activity.
  - >-
    Finally, I'll update the blueprints for `shell.ts`, which is how the system
    monitors active agents via `tmux`.
  - >-
    These changes establish a comprehensive testing blueprint. The next wave of
    agents can now target these specific `TODO` blocks to implement the tests,
    ensuring the system's core logic is robust and reliable.
operations:
  - type: write
    path: test/e2e/cli.test.ts
    content: |
      <<<<<<< SEARCH
      import { exec } from 'child_process';
      import util from 'util';
      import fs from 'fs/promises';
      import path from 'path';

      const execPromise = util.promisify(exec);

      // TODO: Define path to the compiled CLI entry point.
      const cliCommand = 'node ../../dist/cli.js'; // Relative to the test CWD
      const testDir = path.join(__dirname, 'temp-e2e');

      describe('e2e/cli', () => {
        // TODO: Set up a temporary test directory and run `npm run build` before all tests.
        // 1. Delete the temp-e2e directory if it exists.
        // 2. Create a fresh temp-e2e directory.
        // 3. Run `npm run build` from the project root to ensure dist/ is up-to-date.
        beforeAll(async () => {}, 30000); // Increase timeout for build step

        // TODO: Clean up the temporary directory after all tests.
        // 1. Remove the temp-e2e directory.
        afterAll(async () => {});

        // TODO: Set up a temporary CWD for each test.
        // 1. Create a unique subdirectory inside 'temp-e2e' for the test.
        // 2. Change the current working directory to this new subdirectory.
        beforeEach(async () => {});
        
        // TODO: Clean up CWD after each test.
        // 1. Change CWD back to the project root.
        // 2. The main temp-e2e directory will be cleaned up in afterAll.
        afterEach(async () => {});

        describe('init command', () => {
          // TODO: Test `nocaflow init`.
          // It should execute successfully and create the .nocaflow directory.
          // Verify directory structure exists after command runs.
          // 1. Run `nocaflow init`.
          // 2. Check for the existence of `.nocaflow/initialization/plans/todo/.gitkeep`.
          // 3. Check for the existence of `.nocaflow/development/plans/todo/.gitkeep`.
          // 4. Assert that the command's stdout contains a success message.
          it('should initialize a new project structure', async () => {});
        });

        describe('state command', () => {
          // TODO: Test `nocaflow state` in an initialized directory.
          // First, run `init`. Then, run `state`.
          // The command should execute successfully and output a formatted state report.
          // The test should check for key headers in the stdout.
          // 1. Run `nocaflow init`.
          // 2. Run `nocaflow state`.
          // 3. Assert that stdout includes "== nocaflow State ==".
          // 4. Assert that stdout includes "Current Phase: initialization".
          // 5. Assert that stdout includes "== Phase Progress ==".
          it('should display the project state in an initialized directory', async () => {});

          // TODO: Test `nocaflow state` in a directory that has not been initialized.
          // 1. Run `nocaflow state`.
          // 2. The command should exit with a non-zero status code.
          // 3. Assert that stderr contains an error message about `.nocaflow` not being found.
          it('should show an error when run in a non-initialized directory', async () => {});
        });

        describe('no command', () => {
          // TODO: Test running `nocaflow` with no command.
          // It should display the help message.
          // 1. Run `nocaflow` with no arguments.
          // 2. Assert that stdout includes the help text (e.g., "Commands:", "Options:").
          it('should display help when no command is provided', async () => {});
        });
      });
      =======
      import { exec } from 'child_process';
      import util from 'util';
      import fs from 'fs/promises';
      import path from 'path';

      const execPromise = util.promisify(exec);

      // TODO: Define path to the compiled CLI entry point.
      const cliCommand = 'node ../../dist/cli.js'; // Relative to the test CWD
      const testDir = path.join(__dirname, 'temp-e2e');
      // TODO: Define a variable to hold the original CWD.
      // let originalCwd: string;

      describe('e2e/cli', () => {
        // TODO: Set up a temporary test directory and run `npm run build` before all tests.
        // 1. Store the original CWD.
        // 2. Delete the temp-e2e directory if it exists using `fs.rm`.
        // 3. Create a fresh temp-e2e directory using `fs.mkdir`.
        // 4. Run `npm run build` from the project root to ensure dist/ is up-to-date. Use a long timeout.
        beforeAll(async () => {}, 30000); // Increase timeout for build step

        // TODO: Clean up the temporary directory after all tests.
        // 1. Change CWD back to the original CWD.
        // 2. Remove the temp-e2e directory using `fs.rm`.
        afterAll(async () => {});

        // TODO: Set up a temporary CWD for each test.
        // 1. Create a unique subdirectory inside 'temp-e2e' for the test.
        // 2. Change the current working directory to this new subdirectory using `process.chdir`.
        beforeEach(async () => {});
        
        // TODO: Clean up CWD after each test.
        // 1. Change CWD back to the project root path.
        // 2. The main temp-e2e directory will be cleaned up in afterAll.
        afterEach(async () => {});

        describe('init command', () => {
          // TODO: Test `nocaflow init`.
          // It should execute successfully and create the .nocaflow directory.
          // Verify directory structure exists after command runs.
          // 1. Run `cliCommand + ' init'` using `execPromise`.
          // 2. Use `fs.access` to check for `.nocaflow/initialization/plans/todo/.gitkeep`.
          // 3. Use `fs.access` to check for `.nocaflow/development/plans/todo/.gitkeep`.
          // 4. Assert that the command's stdout contains a success message like "initialized successfully".
          it('should initialize a new project structure', async () => {});
        });

        describe('state command', () => {
          // TODO: Test `nocaflow state` in an initialized directory.
          // First, run `init`. Then, run `state`.
          // The command should execute successfully and output a formatted state report.
          // The test should check for key headers in the stdout.
          // 1. Run `cliCommand + ' init'`.
          // 2. Create some dummy plan files to ensure the state command has data to report.
          //    e.g., `fs.writeFile('.nocaflow/initialization/plans/todo/plan1.yml', '')`
          // 3. Run `cliCommand + ' state'`.
          // 4. Assert that stdout includes "== nocaflow State ==".
          // 5. Assert that stdout includes "Current Phase: initialization".
          // 6. Assert that stdout includes "== Phase Progress ==".
          it('should display the project state in an initialized directory', async () => {});

          // TODO: Test `nocaflow state` in a directory that has not been initialized.
          // 1. Run `cliCommand + ' state'` and expect it to fail.
          // 2. Use a try/catch block around `execPromise` or use `expect(...).rejects.toThrow()`.
          // 3. In the catch block, assert that the error's `stderr` contains a message about `.nocaflow` not being found.
          it('should show an error when run in a non-initialized directory', async () => {});
        });

        describe('no command', () => {
          // TODO: Test running `nocaflow` with no command.
          // It should display the help message.
          // 1. Run `cliCommand` with no arguments.
          // 2. Assert that stdout includes the help text (e.g., "Commands:", "Options:").
          it('should display help when no command is provided', async () => {});
        });
      });
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/integration/commands/init.test.ts
    content: |
      <<<<<<< SEARCH
      import { handleInitCommand } from '../../../src/commands/init';
      import fs from 'fs/promises';
      import path from 'path';

      describe('integration/commands/init', () => {
        // TODO: Set up a temporary test directory before each test.
        // Use fs.mkdtemp to create a unique directory in the OS's temp folder.
        // Change the current working directory to the temp directory.
        // 1. Store the original CWD.
        // 2. Create a temp directory using `fs.mkdtemp`.
        // 3. Change CWD to the temp directory.
        beforeEach(async () => {});

        // TODO: Clean up the temporary directory after each test.
        // Change back to the original working directory.
        // Use fs.rm with { recursive: true, force: true }.
        // 1. Change CWD back to the original CWD.
        // 2. Remove the temp directory.
        afterEach(async () => {});

        // TODO: Test case for a fresh initialization.
        // It should create the full .nocaflow directory structure and all .gitkeep files.
        // 1. Call `handleInitCommand({})`.
        // 2. Use `fs.access` to verify that several key directories exist.
        //    - e.g., '.nocaflow/initialization/plans/todo'
        //    - e.g., '.nocaflow/development/plans/failed/report'
        // 3. Use `fs.access` to verify that several key `.gitkeep` files exist.
        //    - e.g., '.nocaflow/initialization/agent-log/.gitkeep'
        it('should create the full .nocaflow directory structure on first run', async () => {});

        // TODO: Test case where .nocaflow already exists.
        // The command should log a warning and exit without modifying anything.
        // This requires mocking console.warn and process.exit.
        // 1. Mock `console.warn` and `process.exit` with `jest.spyOn`.
        // 2. Create the `.nocaflow` directory manually.
        // 3. Call `handleInitCommand({})`.
        // 4. Assert that `console.warn` was called with a specific message.
        // 5. Assert that `process.exit` was called.
        it('should exit with a warning if .nocaflow directory already exists', async () => {});
      });
      =======
      import { handleInitCommand } from '../../../src/commands/init';
      import fs from 'fs/promises';
      import path from 'path';
      import os from 'os';

      describe('integration/commands/init', () => {
        // TODO: Define variables to hold the temp directory path and original CWD.
        // let tempDir: string;
        // let originalCwd: string;

        // TODO: Set up a temporary test directory before each test.
        // Use fs.mkdtemp to create a unique directory in the OS's temp folder.
        // Change the current working directory to the temp directory.
        // 1. Store `process.cwd()` in `originalCwd`.
        // 2. Create a temp directory using `fs.mkdtemp` with a prefix.
        // 3. Change CWD to the temp directory using `process.chdir`.
        beforeEach(async () => {});

        // TODO: Clean up the temporary directory after each test.
        // Change back to the original working directory.
        // Use fs.rm with { recursive: true, force: true }.
        // 1. Change CWD back to `originalCwd`.
        // 2. Remove the `tempDir` using `fs.rm`.
        afterEach(async () => {});

        // TODO: Test case for a fresh initialization.
        // It should create the full .nocaflow directory structure and all .gitkeep files.
        // 1. Call `handleInitCommand({})`.
        // 2. Use `fs.access` to verify that several key directories exist.
        //    - e.g., '.nocaflow/initialization/plans/todo'
        //    - e.g., '.nocaflow/development/plans/failed/report'
        // 3. Use `fs.access` to verify that several key `.gitkeep` files exist.
        //    - e.g., '.nocaflow/initialization/agent-log/.gitkeep'
        //    - e.g., '.nocaflow/development/plans/todo/.gitkeep'
        it('should create the full .nocaflow directory structure on first run', async () => {});

        // TODO: Test case where .nocaflow already exists.
        // The command should log a warning and exit without modifying anything.
        // This requires mocking console.warn and process.exit.
        // 1. Mock `console.warn` using `jest.spyOn(console, 'warn').mockImplementation(() => {})`.
        // 2. Mock `process.exit` using `jest.spyOn(process, 'exit').mockImplementation((() => {}) as (code?: number) => never)`.
        // 3. Create the `.nocaflow` directory manually using `fs.mkdir`.
        // 4. Call `handleInitCommand({})`.
        // 5. Assert that `console.warn` was called with a specific message about the directory existing.
        // 6. Assert that `process.exit` was called with code 1.
        // 7. Restore mocks using `mockRestore()`.
        it('should exit with a warning if .nocaflow directory already exists', async () => {});
      });
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/commands/state.test.ts
    content: |
      <<<<<<< SEARCH
      import { renderProgressBar } from '../../../src/commands/state';

      describe('state command helpers', () => {
        describe('renderProgressBar', () => {
          // TODO: Test case for 0% progress.
          // It should render an empty bar with correct labels.
          // 1. Call `renderProgressBar(0, 10, 10)`.
          // 2. Assert the output is `[----------] (0/10 plans done)`.
          it('should render an empty bar for 0 progress', () => {});

          // TODO: Test case for 50% progress.
          // It should render a half-filled bar.
          // 1. Call `renderProgressBar(5, 10, 10)`.
          // 2. Assert the output is `[▇▇▇▇▇-----] (5/10 plans done)`.
          it('should render a half-filled bar for 50% progress', () => {});

          // TODO: Test case for 100% progress.
          // It should render a full bar.
          // 1. Call `renderProgressBar(10, 10, 10)`.
          // 2. Assert the output is `[▇▇▇▇▇▇▇▇▇▇] (10/10 plans done)`.
          it('should render a full bar for 100% progress', () => {});

          // TODO: Test case with a different bar length.
          // It should respect the length parameter.
          // 1. Call `renderProgressBar(1, 2, 20)`.
          // 2. Assert the filled part has 10 '▇' characters.
          it('should handle different bar lengths', () => {});

          // TODO: Test case for progress that isn't a clean fraction.
          // It should round to the nearest whole character.
          // 1. Call `renderProgressBar(1, 3, 10)`.
          // 2. 33% should round to 3 filled characters.
          // 3. Assert the output is `[▇▇▇-------] (1/3 plans done)`.
          it('should round to the nearest character for fractional progress', () => {});

          // TODO: Test case for a total of 0.
          // It should not throw an error and should render an empty bar.
          // 1. Call `renderProgressBar(0, 0, 10)`.
          // 2. Assert it does not throw a "division by zero" error.
          // 3. Assert the output is `[----------] (0/0 plans done)`.
          it('should handle a total of 0 gracefully', () => {});
        });
      });
      =======
      import { renderProgressBar } from '../../../src/commands/state';

      describe('state command helpers', () => {
        describe('renderProgressBar', () => {
          // TODO: Test case for 0% progress.
          // It should render an empty bar with correct labels.
          // 1. Call `renderProgressBar(0, 10, 10)`.
          // 2. Assert the output is `[----------] (0/10 plans done)`.
          it('should render an empty bar for 0 progress', () => {});

          // TODO: Test case for 50% progress.
          // It should render a half-filled bar.
          // 1. Call `renderProgressBar(5, 10, 10)`.
          // 2. Assert the output is `[▇▇▇▇▇-----] (5/10 plans done)`.
          it('should render a half-filled bar for 50% progress', () => {});

          // TODO: Test case for 100% progress.
          // It should render a full bar.
          // 1. Call `renderProgressBar(10, 10, 10)`.
          // 2. Assert the output is `[▇▇▇▇▇▇▇▇▇▇] (10/10 plans done)`.
          it('should render a full bar for 100% progress', () => {});

          // TODO: Test case with a different bar length.
          // It should respect the length parameter.
          // 1. Call `renderProgressBar(1, 2, 20)`.
          // 2. Assert the filled part has 10 '▇' characters.
          // 3. Assert the output is `[▇▇▇▇▇▇▇▇▇▇----------] (1/2 plans done)`.
          it('should handle different bar lengths', () => {});

          // TODO: Test case for progress that isn't a clean fraction.
          // It should round to the nearest whole character.
          // 1. Call `renderProgressBar(1, 3, 10)`.
          // 2. 33% should round to 3 filled characters.
          // 3. Assert the output is `[▇▇▇-------] (1/3 plans done)`.
          it('should round to the nearest character for fractional progress', () => {});

          // TODO: Test case for a total of 0.
          // It should not throw an error and should render an empty bar.
          // 1. Call `renderProgressBar(0, 0, 10)`.
          // 2. Assert it does not throw a "division by zero" error.
          // 3. Assert the output is `[----------] (0/0 plans done)`.
          it('should handle a total of 0 gracefully', () => {});
        });
      });
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/utils/fs.test.ts
    content: >
      <<<<<<< SEARCH

      import { getPhaseStats, getFailedReports, readPlan } from
      '../../../src/utils/fs';

      import fs from 'fs/promises';

      import yaml from 'js-yaml';

      import dayjs from 'dayjs';


      // TODO: Mock the 'fs/promises' module to control filesystem operations.

      jest.mock('fs/promises');

      const mockedFs = fs as jest.Mocked<typeof fs>;


      describe('utils/fs', () => {
        afterEach(() => {
          jest.clearAllMocks();
        });

        describe('getPhaseStats', () => {
          // TODO: Test case where .nocaflow directory exists with plans.
          // It should correctly count plans in todo, doing, done, etc., for each phase.
          // 1. Mock `fs.readdir` to return different arrays of filenames for different paths.
          //    - e.g., `.../initialization/plans/todo` -> `['a.yml', 'b.yml']` (count: 2)
          //    - e.g., `.../development/plans/done` -> `['c.yml']` (count: 1)
          // 2. Call `getPhaseStats()`.
          // 3. Assert `stats.initialization.todo` is 2 and `stats.development.done` is 1.
          // 4. Assert `total` is calculated correctly for each phase.
          it('should correctly count plans across different statuses and phases', async () => {});

          // TODO: Test case where a phase directory is missing.
          // It should handle the error gracefully and count as 0.
          // 1. Mock `fs.readdir` to throw an ENOENT error for any path under `.../development/...`.
          // 2. Call `getPhaseStats()`.
          // 3. Assert all counts for `development` are 0.
          it('should return 0 for a missing phase directory', async () => {});

          // TODO: Test case where a status directory is missing (e.g., no 'review' plans).
          // It should count that status as 0.
          // 1. Mock `fs.readdir` to throw an ENOENT error for `.../initialization/plans/review`.
          // 2. Call `getPhaseStats()`.
          // 3. Assert `stats.initialization.review` is 0.
          it('should return 0 for a missing status directory', async () => {});

          // TODO: Test case with an empty .nocaflow directory.
          // All counts should be 0.
          // 1. Mock `fs.readdir` to return `[]` for all status directories.
          // 2. Call `getPhaseStats()`.
          // 3. Assert all counts for all phases are 0.
          it('should return all zeros for an empty directory structure', async () => {});
        });

        describe('getFailedReports', () => {
          // TODO: Test case with recent and old failure reports.
          // It should only return reports within the specified `hours` lookback period.
          // 1. Mock `fs.readdir` to return two report files.
          // 2. Mock `fs.stat` to return a recent `birthtime` for one and an old `birthtime` for the other.
          // 3. Mock `fs.readFile` for the recent file.
          // 4. Call `getFailedReports(24)`.
          // 5. Assert the result contains only the recent report.
          it('should only return reports within the lookback period', async () => {});

          // TODO: Test case where report files have correctly formatted names and content.
          // It should correctly parse planId, partId, and summary from the filename and content.
          // 1. Mock `fs.readdir` to return `['plan1.partA.report.md']`.
          // 2. Mock `fs.stat` to return a recent `birthtime`.
          // 3. Mock `fs.readFile` to return markdown with `## Summary\nThis is the reason.`.
          // 4. Call `getFailedReports(24)`.
          // 5. Assert `result[0].planId` is 'plan1', `partId` is 'partA', and `reason` is 'This is the reason.'.
          it('should correctly parse report details', async () => {});

          // TODO: Test case with no report files.
          // It should return an empty array.
          // 1. Mock `fs.readdir` to return `[]`.
          // 2. Call `getFailedReports(24)`.
          // 3. Assert the result is an empty array.
          it('should return an empty array when no reports are found', async () => {});

          // TODO: Test case where a report file is malformed (e.g., no "## Summary" section).
          // It should handle the parsing error gracefully.
          // 1. Mock `fs.readdir` and `fs.stat` for a recent report.
          // 2. Mock `fs.readFile` to return content *without* a `## Summary` section.
          // 3. Call `getFailedReports(24)`.
          // 4. Assert the `reason` field has a sensible fallback, like 'Could not parse summary.'.
          it('should handle malformed report content', async () => {});
        });

        describe('readPlan', () => {
          // TODO: Test case with a valid YAML plan file.
          // It should correctly parse the YAML into a Plan object.
          // 1. Mock `fs.readFile` to return a valid YAML string.
          // 2. Call `readPlan('path/to/plan.yml')`.
          // 3. Assert that the returned object matches the parsed structure of the YAML.
          it('should parse a valid plan file', async () => {});

          // TODO: Test case with a non-existent file path.
          // It should throw a file-not-found error.
          // 1. Mock `fs.readFile` to throw an error with `code: 'ENOENT'`.
          // 2. Call `readPlan` and assert that it throws an error.
          it('should throw an error for a non-existent file', async () => {});

          // TODO: Test case with an invalid YAML file.
          // It should throw a YAML parsing error.
          // 1. Mock `fs.readFile` to return a string with invalid YAML syntax (e.g., `key: - invalid:`).
          // 2. Call `readPlan` and assert that it throws a YAMLException.
          it('should throw an error for invalid YAML', async () => {});
        });
      });

      =======

      import { getPhaseStats, getFailedReports, readPlan } from
      '../../../src/utils/fs';

      import fs from 'fs/promises';

      import yaml from 'js-yaml';

      import dayjs from 'dayjs';

      import { Plan } from '../../../src/models/plan';


      // TODO: Mock the 'fs/promises' module to control filesystem operations.

      jest.mock('fs/promises');

      const mockedFs = fs as jest.Mocked<typeof fs>;


      describe('utils/fs', () => {
        afterEach(() => {
          jest.clearAllMocks();
        });

        describe('getPhaseStats', () => {
          // TODO: Test case where .nocaflow directory exists with plans.
          // It should correctly count plans in todo, doing, done, etc., for each phase.
          // 1. Mock `mockedFs.readdir` to resolve with different arrays of filenames for different paths.
          //    - e.g., for path `.../initialization/plans/todo`, resolve `['a.yml', 'b.yml']`.
          //    - e.g., for path `.../development/plans/done`, resolve `['c.yml']`.
          //    - Use `mockResolvedValue` for simple cases or `mockImplementation` for path-dependent logic.
          // 2. Call `getPhaseStats()`.
          // 3. Assert `stats.initialization.todo` is 2 and `stats.development.done` is 1.
          // 4. Assert `total` is calculated correctly for each phase.
          it('should correctly count plans across different statuses and phases', async () => {});

          // TODO: Test case where a phase directory is missing.
          // It should handle the error gracefully and count as 0.
          // 1. Mock `mockedFs.readdir` to throw an ENOENT error for any path under `.../development/...`.
          //    - `const error: NodeJS.ErrnoException = new Error('...'); error.code = 'ENOENT';`
          //    - `mockImplementation(path => path.includes('development') ? Promise.reject(error) : Promise.resolve([]))`
          // 2. Call `getPhaseStats()`.
          // 3. Assert all counts for `development` are 0.
          it('should return 0 for a missing phase directory', async () => {});

          // TODO: Test case where a status directory is missing (e.g., no 'review' plans).
          // It should count that status as 0.
          // 1. Mock `mockedFs.readdir` to throw an ENOENT error for a specific path like `.../initialization/plans/review`.
          // 2. Call `getPhaseStats()`.
          // 3. Assert `stats.initialization.review` is 0.
          it('should return 0 for a missing status directory', async () => {});

          // TODO: Test case with an empty .nocaflow directory.
          // All counts should be 0.
          // 1. Mock `mockedFs.readdir` to resolve `[]` for all status directories.
          // 2. Call `getPhaseStats()`.
          // 3. Assert all counts for all phases are 0.
          it('should return all zeros for an empty directory structure', async () => {});
        });

        describe('getFailedReports', () => {
          // TODO: Test case with recent and old failure reports.
          // It should only return reports within the specified `hours` lookback period.
          // 1. Mock `mockedFs.readdir` to resolve `['recent.report.md', 'old.report.md']`.
          // 2. Mock `mockedFs.stat` to return a recent `birthtime` for one and an old `birthtime` for the other.
          //    - `mockedFs.stat.mockResolvedValueOnce({ birthtime: dayjs().subtract(1, 'hour').toDate() } as fs.Stats)`
          //    - `mockedFs.stat.mockResolvedValueOnce({ birthtime: dayjs().subtract(48, 'hour').toDate() } as fs.Stats)`
          // 3. Mock `mockedFs.readFile` to resolve with content for the recent file.
          // 4. Call `getFailedReports(24)`.
          // 5. Assert the result contains only the recent report and has a length of 1.
          it('should only return reports within the lookback period', async () => {});

          // TODO: Test case where report files have correctly formatted names and content.
          // It should correctly parse planId, partId, and summary from the filename and content.
          // 1. Mock `mockedFs.readdir` to resolve `['plan1.partA.report.md']`.
          // 2. Mock `mockedFs.stat` to resolve a recent `birthtime`.
          // 3. Mock `mockedFs.readFile` to resolve markdown `## Summary\nThis is the reason.`.
          // 4. Call `getFailedReports(24)`.
          // 5. Assert `result[0].planId` is 'plan1', `partId` is 'partA', and `reason` is 'This is the reason.'.
          it('should correctly parse report details', async () => {});

          // TODO: Test case with no report files.
          // It should return an empty array.
          // 1. Mock `mockedFs.readdir` to resolve `[]`.
          // 2. Call `getFailedReports(24)`.
          // 3. Assert the result is an empty array.
          it('should return an empty array when no reports are found', async () => {});

          // TODO: Test case where a report file is malformed (e.g., no "## Summary" section).
          // It should handle the parsing error gracefully.
          // 1. Mock `mockedFs.readdir` and `mockedFs.stat` for a recent report.
          // 2. Mock `mockedFs.readFile` to return content *without* a `## Summary` section.
          // 3. Call `getFailedReports(24)`.
          // 4. Assert the `reason` field has a sensible fallback, like 'Could not parse summary.'.
          it('should handle malformed report content', async () => {});
        });

        describe('readPlan', () => {
          // TODO: Test case with a valid YAML plan file.
          // It should correctly parse the YAML into a Plan object.
          // 1. Define a valid YAML string.
          // 2. Mock `mockedFs.readFile` to resolve with the YAML string.
          // 3. Call `readPlan('path/to/plan.yml')`.
          // 4. Assert that the returned object matches the parsed structure of the YAML.
          it('should parse a valid plan file', async () => {});

          // TODO: Test case with a non-existent file path.
          // It should throw a file-not-found error.
          // 1. Mock `mockedFs.readFile` to reject with an ENOENT error.
          // 2. Call `readPlan` and assert that it throws, e.g., `await expect(readPlan(...)).rejects.toThrow()`.
          it('should throw an error for a non-existent file', async () => {});

          // TODO: Test case with an invalid YAML file.
          // It should throw a YAML parsing error.
          // 1. Mock `mockedFs.readFile` to resolve with a string of invalid YAML syntax (e.g., `key: - invalid:`).
          // 2. Call `readPlan` and assert that it throws an error that can be identified as a YAMLException.
          it('should throw an error for invalid YAML', async () => {});
        });
      });

      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/utils/git.test.ts
    content: |
      <<<<<<< SEARCH
      import { getGitLog } from '../../../src/utils/git';
      import { exec } from 'child_process';

      jest.mock('child_process');
      const mockedExec = exec as jest.Mock;

      describe('utils/git', () => {
        afterEach(() => {
          jest.clearAllMocks();
        });

        describe('getGitLog', () => {
          // TODO: Test case with git log output containing worktree information.
          // It should correctly parse the commit hash, message, and worktree name.
          // 1. Mock `exec` to return porcelain worktree list output for `git worktree list`.
          // 2. Mock `exec` to return formatted log output for `git log`, where one entry has a ref like `HEAD -> worktrees/my-feature`.
          // 3. Call `getGitLog(5)`.
          // 4. Find the corresponding commit in the result and assert its `worktree` property is `my-feature`.
          it('should parse commits with worktree information', async () => {});

          // TODO: Test case with git log output for commits not in a worktree (e.g., on main).
          // The 'worktree' property should be null.
          // 1. Mock `exec` for worktrees and logs.
          // 2. Ensure one log entry has refs like `HEAD -> main, origin/main`.
          // 3. Call `getGitLog(5)`.
          // 4. Find that commit and assert its `worktree` property is `null`.
          it('should handle commits not associated with a worktree', async () => {});

          // TODO: Test case where `git worktree list` command fails.
          // It should gracefully handle the error and continue, possibly with null worktrees.
          // 1. Mock `exec` to throw an error when the command is `git worktree list --porcelain`.
          // 2. Mock `exec` to return valid log output for `git log`.
          // 3. Call `getGitLog(5)`.
          // 4. Assert that the function does not throw.
          // 5. Assert that all returned commits have `worktree: null`.
          it('should handle git worktree command failure', async () => {});

          // TODO: Test case where `git log` command fails.
          // It should return an empty array or throw an error.
          // 1. Mock `exec` to return valid worktree info.
          // 2. Mock `exec` to throw an error when the command is `git log ...`.
          // 3. Call `getGitLog(5)`.
          // 4. Assert that the result is an empty array.
          it('should return an empty array if git log fails', async () => {});

          // TODO: Test case with an empty git log output.
          // It should return an empty array.
          // 1. Mock `exec` for worktrees.
          // 2. Mock `exec` for `git log` to return an empty string in stdout.
          // 3. Call `getGitLog(5)`.
          // 4. Assert the result is an empty array.
          it('should return an empty array for an empty git log', async () => {});
        });
      });
      =======
      import { getGitLog } from '../../../src/utils/git';
      import { exec } from 'child_process';

      jest.mock('child_process');
      const mockedExec = exec as jest.Mock;

      describe('utils/git', () => {
        afterEach(() => {
          jest.clearAllMocks();
        });

        describe('getGitLog', () => {
          // TODO: Test case with git log output containing worktree information.
          // It should correctly parse the commit hash, message, and worktree name.
          // 1. Mock `mockedExec` to handle two calls: `git worktree list` and `git log`.
          //    - For `worktree list`, return porcelain output: `worktree /path/to/worktrees/my-feature\nHEAD ...\n`
          //    - For `git log`, return formatted output where one entry's refs include `HEAD -> worktrees/my-feature`.
          //      e.g., `hash1|message1|HEAD -> worktrees/my-feature`
          // 2. Call `getGitLog(5)`.
          // 3. Find the corresponding commit in the result and assert its `worktree` property is `my-feature`.
          it('should parse commits with worktree information', async () => {});

          // TODO: Test case with git log output for commits not in a worktree (e.g., on main).
          // The 'worktree' property should be null.
          // 1. Mock `mockedExec` for worktrees and logs.
          // 2. Ensure one log entry has refs like `HEAD -> main, origin/main`.
          // 3. Call `getGitLog(5)`.
          // 4. Find that commit and assert its `worktree` property is `null`.
          it('should handle commits not associated with a worktree', async () => {});

          // TODO: Test case where `git worktree list` command fails.
          // It should gracefully handle the error and continue, possibly with null worktrees.
          // 1. Mock `mockedExec` to throw an error when the command includes `git worktree list`.
          // 2. Mock `mockedExec` to return valid log output for the `git log` command.
          // 3. Call `getGitLog(5)`.
          // 4. Assert that the function does not throw.
          // 5. Assert that all returned commits have `worktree: null`.
          it('should handle git worktree command failure', async () => {});

          // TODO: Test case where `git log` command fails.
          // It should return an empty array.
          // 1. Mock `mockedExec` to return valid worktree info.
          // 2. Mock `mockedExec` to throw an error when the command includes `git log`.
          // 3. Call `getGitLog(5)`.
          // 4. Assert that the result is an empty array.
          it('should return an empty array if git log fails', async () => {});

          // TODO: Test case with an empty git log output.
          // It should return an empty array.
          // 1. Mock `mockedExec` for worktrees.
          // 2. Mock `mockedExec` for `git log` to return an empty string for stdout.
          // 3. Call `getGitLog(5)`.
          // 4. Assert the result is an empty array.
          it('should return an empty array for an empty git log', async () => {});
        });
      });
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/utils/logs.test.ts
    content: |
      <<<<<<< SEARCH
      import { getRecentLogs } from '../../../src/utils/logs';
      import fs from 'fs/promises';

      jest.mock('fs/promises');
      const mockedFs = fs as jest.Mocked<typeof fs>;

      describe('utils/logs', () => {
        afterEach(() => {
          jest.clearAllMocks();
        });

        describe('getRecentLogs', () => {
          // TODO: Test case with multiple log files across different phases.
          // It should read from all relevant directories.
          // 1. Mock `fs.readdir` to return `['a.log']` for the init dir and `['b.log']` for the dev dir.
          // 2. Mock `fs.readFile` to return different log content for `a.log` and `b.log`.
          // 3. Call `getRecentLogs(10)`.
          // 4. Assert that the result contains parsed entries from both files.
          it('should aggregate logs from all phase directories', async () => {});

          // TODO: Test case with a log file containing valid and malformed lines.
          // It should parse valid lines and skip malformed ones.
          // 1. Mock `fs.readdir` to return one log file.
          // 2. Mock `fs.readFile` to return a string with one valid log line and one invalid line.
          // 3. Call `getRecentLogs(10)`.
          // 4. Assert that the result contains exactly one entry, corresponding to the valid line.
          it('should correctly parse valid log lines and skip invalid ones', async () => {});

          // TODO: Test case with more log entries than the specified limit.
          // It should return only the most recent 'limit' number of entries, sorted descending by timestamp.
          // 1. Mock `fs.readdir` and `fs.readFile` to produce 10 log entries with out-of-order timestamps.
          // 2. Call `getRecentLogs(5)`.
          // 3. Assert the result has a length of 5.
          // 4. Assert the timestamps in the result are in descending order.
          it('should return the correct number of recent, sorted log entries', async () => {});

          // TODO: Test case where log directories do not exist.
          // It should handle the error and return an empty array.
          // 1. Mock `fs.readdir` to throw an ENOENT error for all log directories.
          // 2. Call `getRecentLogs(5)`.
          // 3. Assert the result is an empty array.
          it('should return an empty array if log directories are missing', async () => {});

          // TODO: Test case with empty log files.
          // It should return an empty array.
          // 1. Mock `fs.readdir` to return log file names.
          // 2. Mock `fs.readFile` to return an empty string for all files.
          // 3. Call `getRecentLogs(5)`.
          // 4. Assert the result is an empty array.
          it('should return an empty array for empty log files', async () => {});
        });
      });
      =======
      import { getRecentLogs } from '../../../src/utils/logs';
      import fs from 'fs/promises';

      jest.mock('fs/promises');
      const mockedFs = fs as jest.Mocked<typeof fs>;

      describe('utils/logs', () => {
        afterEach(() => {
          jest.clearAllMocks();
        });

        describe('getRecentLogs', () => {
          // TODO: Test case with multiple log files across different phases.
          // It should read from all relevant directories.
          // 1. Mock `mockedFs.readdir` to return `['a.log']` for the init dir and `['b.log']` for the dev dir.
          // 2. Mock `mockedFs.readFile` to return different log content for `a.log` and `b.log`.
          // 3. Call `getRecentLogs(10)`.
          // 4. Assert that the result contains parsed entries from both files (e.g., `result.length === 2`).
          it('should aggregate logs from all phase directories', async () => {});

          // TODO: Test case with a log file containing valid and malformed lines.
          // It should parse valid lines and skip malformed ones.
          // 1. Mock `mockedFs.readdir` to return one log file.
          // 2. Mock `mockedFs.readFile` to return a string with one valid log line and one invalid line.
          //    - e.g., `valid line\ninvalid line`
          // 3. Call `getRecentLogs(10)`.
          // 4. Assert that the result contains exactly one entry, corresponding to the valid line.
          it('should correctly parse valid log lines and skip invalid ones', async () => {});

          // TODO: Test case with more log entries than the specified limit.
          // It should return only the most recent 'limit' number of entries, sorted descending by timestamp.
          // 1. Mock `mockedFs.readdir` and `mockedFs.readFile` to produce multiple log entries with out-of-order timestamps.
          // 2. Call `getRecentLogs(5)`.
          // 3. Assert the result has a length of 5.
          // 4. Assert the timestamps in the result are in descending order by comparing `result[i].timestamp >= result[i+1].timestamp`.
          it('should return the correct number of recent, sorted log entries', async () => {});

          // TODO: Test case where log directories do not exist.
          // It should handle the error and return an empty array.
          // 1. Mock `mockedFs.readdir` to throw an ENOENT error for all log directories.
          // 2. Call `getRecentLogs(5)`.
          // 3. Assert the result is an empty array.
          it('should return an empty array if log directories are missing', async () => {});

          // TODO: Test case with empty log files.
          // It should return an empty array.
          // 1. Mock `mockedFs.readdir` to return log file names.
          // 2. Mock `mockedFs.readFile` to resolve with an empty string for all files.
          // 3. Call `getRecentLogs(5)`.
          // 4. Assert the result is an empty array.
          it('should return an empty array for empty log files', async () => {});
        });
      });
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/unit/utils/shell.test.ts
    content: |
      <<<<<<< SEARCH
      import { getActiveAgents } from '../../../src/utils/shell';
      import { exec } from 'child_process';
      import dayjs from 'dayjs';

      jest.mock('child_process');
      const mockedExec = exec as jest.Mock;

      describe('utils/shell', () => {
        afterEach(() => {
          jest.clearAllMocks();
        });

        describe('getActiveAgents', () => {
          // TODO: Test case with `tmux ls` output for various agent types.
          // It should correctly parse init, dev, scaffold, and qa agents.
          // 1. Mock `exec` to return a multi-line string with session names like:
          //    - `init-part1 123 1672531200`
          //    - `dev-part2 456 1672531200`
          //    - `init-scaffold-plan1 789 1672531200`
          //    - `qa-plan2 101 1672531200`
          //    - `non-agent-session 112 1672531200`
          // 2. Call `getActiveAgents()`.
          // 3. Assert the result contains 4 agents.
          // 4. Assert each agent has the correct phase, planId, partId, etc.
          it('should parse all types of agent sessions and ignore non-agent sessions', async () => {});

          // TODO: Test case with `tmux ls` output that is empty.
          // It should return an empty array.
          // 1. Mock `exec` to return stdout as an empty string.
          // 2. Call `getActiveAgents()`.
          // 3. Assert the result is an empty array.
          it('should return an empty array when there are no tmux sessions', async () => {});

          // TODO: Test case where `tmux ls` command fails.
          // It should catch the error and return an empty array.
          // 1. Mock `exec` to throw an error.
          // 2. Call `getActiveAgents()`.
          // 3. Assert the result is an empty array.
          it('should return an empty array if tmux is not running', async () => {});

          // TODO: Test case to verify runtime calculation.
          // Mocks the current time and session activity timestamp to check the relative time string.
          // 1. Mock `Date.now` or use a time-mocking library to control "now".
          // 2. Mock `exec` to return a session with a specific activity timestamp.
          // 3. Call `getActiveAgents()`.
          // 4. Assert the `runtime` string is the expected relative time (e.g., "5 minutes").
          it('should correctly calculate agent runtime', async () => {});
        });
      });
      =======
      import { getActiveAgents } from '../../../src/utils/shell';
      import { exec } from 'child_process';
      import dayjs from 'dayjs';
      import relativeTime from 'dayjs/plugin/relativeTime';

      jest.mock('child_process');
      const mockedExec = exec as jest.Mock;
      dayjs.extend(relativeTime);

      describe('utils/shell', () => {
        afterEach(() => {
          jest.clearAllMocks();
        });

        describe('getActiveAgents', () => {
          // TODO: Test case with `tmux ls` output for various agent types.
          // It should correctly parse init, dev, scaffold, and qa agents.
          // 1. Mock `mockedExec` to return a multi-line string with session names like:
          //    - `init-part1 123 1672531200`
          //    - `dev-part2 456 1672531200`
          //    - `init-scaffold-plan1 789 1672531200`
          //    - `qa-plan2 101 1672531200`
          //    - `non-agent-session 112 1672531200`
          // 2. Call `getActiveAgents()`.
          // 3. Assert the result contains 4 agents.
          // 4. Assert each agent has the correct phase, planId, partId, etc.
          it('should parse all types of agent sessions and ignore non-agent sessions', async () => {});

          // TODO: Test case with `tmux ls` output that is empty.
          // It should return an empty array.
          // 1. Mock `mockedExec` to have a callback that provides an empty string for stdout.
          // 2. Call `getActiveAgents()`.
          // 3. Assert the result is an empty array.
          it('should return an empty array when there are no tmux sessions', async () => {});

          // TODO: Test case where `tmux ls` command fails.
          // It should catch the error and return an empty array.
          // 1. Mock `mockedExec` to have a callback that passes an error as the first argument.
          // 2. Call `getActiveAgents()`.
          // 3. Assert the result is an empty array.
          it('should return an empty array if tmux is not running', async () => {});

          // TODO: Test case to verify runtime calculation.
          // Mocks the current time and session activity timestamp to check the relative time string.
          // 1. Use `jest.spyOn(Date, 'now').mockReturnValue(...)` to freeze the current time.
          // 2. Mock `mockedExec` to return a session with a specific activity timestamp that is, e.g., 5 minutes before the mocked "now".
          // 3. Call `getActiveAgents()`.
          // 4. Assert the `runtime` string is the expected relative time (e.g., "5 minutes").
          // 5. Restore the mock for `Date.now`.
          it('should correctly calculate agent runtime', async () => {});
        });
      });
      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  test/e2e/cli.test.ts: |-
    import { exec } from 'child_process';
    import util from 'util';
    import fs from 'fs/promises';
    import path from 'path';

    const execPromise = util.promisify(exec);

    // TODO: Define path to the compiled CLI entry point.
    const cliCommand = 'node ../../dist/cli.js'; // Relative to the test CWD
    const testDir = path.join(__dirname, 'temp-e2e');

    describe('e2e/cli', () => {
      // TODO: Set up a temporary test directory and run `npm run build` before all tests.
      // 1. Delete the temp-e2e directory if it exists.
      // 2. Create a fresh temp-e2e directory.
      // 3. Run `npm run build` from the project root to ensure dist/ is up-to-date.
      beforeAll(async () => {}, 30000); // Increase timeout for build step

      // TODO: Clean up the temporary directory after all tests.
      // 1. Remove the temp-e2e directory.
      afterAll(async () => {});

      // TODO: Set up a temporary CWD for each test.
      // 1. Create a unique subdirectory inside 'temp-e2e' for the test.
      // 2. Change the current working directory to this new subdirectory.
      beforeEach(async () => {});
      
      // TODO: Clean up CWD after each test.
      // 1. Change CWD back to the project root.
      // 2. The main temp-e2e directory will be cleaned up in afterAll.
      afterEach(async () => {});

      describe('init command', () => {
        // TODO: Test `nocaflow init`.
        // It should execute successfully and create the .nocaflow directory.
        // Verify directory structure exists after command runs.
        // 1. Run `nocaflow init`.
        // 2. Check for the existence of `.nocaflow/initialization/plans/todo/.gitkeep`.
        // 3. Check for the existence of `.nocaflow/development/plans/todo/.gitkeep`.
        // 4. Assert that the command's stdout contains a success message.
        it('should initialize a new project structure', async () => {});
      });

      describe('state command', () => {
        // TODO: Test `nocaflow state` in an initialized directory.
        // First, run `init`. Then, run `state`.
        // The command should execute successfully and output a formatted state report.
        // The test should check for key headers in the stdout.
        // 1. Run `nocaflow init`.
        // 2. Run `nocaflow state`.
        // 3. Assert that stdout includes "== nocaflow State ==".
        // 4. Assert that stdout includes "Current Phase: initialization".
        // 5. Assert that stdout includes "== Phase Progress ==".
        it('should display the project state in an initialized directory', async () => {});

        // TODO: Test `nocaflow state` in a directory that has not been initialized.
        // 1. Run `nocaflow state`.
        // 2. The command should exit with a non-zero status code.
        // 3. Assert that stderr contains an error message about `.nocaflow` not being found.
        it('should show an error when run in a non-initialized directory', async () => {});
      });

      describe('no command', () => {
        // TODO: Test running `nocaflow` with no command.
        // It should display the help message.
        // 1. Run `nocaflow` with no arguments.
        // 2. Assert that stdout includes the help text (e.g., "Commands:", "Options:").
        it('should display help when no command is provided', async () => {});
      });
    });
  test/integration/commands/init.test.ts: |-
    import { handleInitCommand } from '../../../src/commands/init';
    import fs from 'fs/promises';
    import path from 'path';

    describe('integration/commands/init', () => {
      // TODO: Set up a temporary test directory before each test.
      // Use fs.mkdtemp to create a unique directory in the OS's temp folder.
      // Change the current working directory to the temp directory.
      // 1. Store the original CWD.
      // 2. Create a temp directory using `fs.mkdtemp`.
      // 3. Change CWD to the temp directory.
      beforeEach(async () => {});

      // TODO: Clean up the temporary directory after each test.
      // Change back to the original working directory.
      // Use fs.rm with { recursive: true, force: true }.
      // 1. Change CWD back to the original CWD.
      // 2. Remove the temp directory.
      afterEach(async () => {});

      // TODO: Test case for a fresh initialization.
      // It should create the full .nocaflow directory structure and all .gitkeep files.
      // 1. Call `handleInitCommand({})`.
      // 2. Use `fs.access` to verify that several key directories exist.
      //    - e.g., '.nocaflow/initialization/plans/todo'
      //    - e.g., '.nocaflow/development/plans/failed/report'
      // 3. Use `fs.access` to verify that several key `.gitkeep` files exist.
      //    - e.g., '.nocaflow/initialization/agent-log/.gitkeep'
      it('should create the full .nocaflow directory structure on first run', async () => {});

      // TODO: Test case where .nocaflow already exists.
      // The command should log a warning and exit without modifying anything.
      // This requires mocking console.warn and process.exit.
      // 1. Mock `console.warn` and `process.exit` with `jest.spyOn`.
      // 2. Create the `.nocaflow` directory manually.
      // 3. Call `handleInitCommand({})`.
      // 4. Assert that `console.warn` was called with a specific message.
      // 5. Assert that `process.exit` was called.
      it('should exit with a warning if .nocaflow directory already exists', async () => {});
    });
  test/unit/commands/state.test.ts: |-
    import { renderProgressBar } from '../../../src/commands/state';

    describe('state command helpers', () => {
      describe('renderProgressBar', () => {
        // TODO: Test case for 0% progress.
        // It should render an empty bar with correct labels.
        // 1. Call `renderProgressBar(0, 10, 10)`.
        // 2. Assert the output is `[----------] (0/10 plans done)`.
        it('should render an empty bar for 0 progress', () => {});

        // TODO: Test case for 50% progress.
        // It should render a half-filled bar.
        // 1. Call `renderProgressBar(5, 10, 10)`.
        // 2. Assert the output is `[▇▇▇▇▇-----] (5/10 plans done)`.
        it('should render a half-filled bar for 50% progress', () => {});

        // TODO: Test case for 100% progress.
        // It should render a full bar.
        // 1. Call `renderProgressBar(10, 10, 10)`.
        // 2. Assert the output is `[▇▇▇▇▇▇▇▇▇▇] (10/10 plans done)`.
        it('should render a full bar for 100% progress', () => {});

        // TODO: Test case with a different bar length.
        // It should respect the length parameter.
        // 1. Call `renderProgressBar(1, 2, 20)`.
        // 2. Assert the filled part has 10 '▇' characters.
        it('should handle different bar lengths', () => {});

        // TODO: Test case for progress that isn't a clean fraction.
        // It should round to the nearest whole character.
        // 1. Call `renderProgressBar(1, 3, 10)`.
        // 2. 33% should round to 3 filled characters.
        // 3. Assert the output is `[▇▇▇-------] (1/3 plans done)`.
        it('should round to the nearest character for fractional progress', () => {});

        // TODO: Test case for a total of 0.
        // It should not throw an error and should render an empty bar.
        // 1. Call `renderProgressBar(0, 0, 10)`.
        // 2. Assert it does not throw a "division by zero" error.
        // 3. Assert the output is `[----------] (0/0 plans done)`.
        it('should handle a total of 0 gracefully', () => {});
      });
    });
  test/unit/utils/git.test.ts: |-
    import { getGitLog } from '../../../src/utils/git';
    import { exec } from 'child_process';

    jest.mock('child_process');
    const mockedExec = exec as jest.Mock;

    describe('utils/git', () => {
      afterEach(() => {
        jest.clearAllMocks();
      });

      describe('getGitLog', () => {
        // TODO: Test case with git log output containing worktree information.
        // It should correctly parse the commit hash, message, and worktree name.
        // 1. Mock `exec` to return porcelain worktree list output for `git worktree list`.
        // 2. Mock `exec` to return formatted log output for `git log`, where one entry has a ref like `HEAD -> worktrees/my-feature`.
        // 3. Call `getGitLog(5)`.
        // 4. Find the corresponding commit in the result and assert its `worktree` property is `my-feature`.
        it('should parse commits with worktree information', async () => {});

        // TODO: Test case with git log output for commits not in a worktree (e.g., on main).
        // The 'worktree' property should be null.
        // 1. Mock `exec` for worktrees and logs.
        // 2. Ensure one log entry has refs like `HEAD -> main, origin/main`.
        // 3. Call `getGitLog(5)`.
        // 4. Find that commit and assert its `worktree` property is `null`.
        it('should handle commits not associated with a worktree', async () => {});

        // TODO: Test case where `git worktree list` command fails.
        // It should gracefully handle the error and continue, possibly with null worktrees.
        // 1. Mock `exec` to throw an error when the command is `git worktree list --porcelain`.
        // 2. Mock `exec` to return valid log output for `git log`.
        // 3. Call `getGitLog(5)`.
        // 4. Assert that the function does not throw.
        // 5. Assert that all returned commits have `worktree: null`.
        it('should handle git worktree command failure', async () => {});

        // TODO: Test case where `git log` command fails.
        // It should return an empty array or throw an error.
        // 1. Mock `exec` to return valid worktree info.
        // 2. Mock `exec` to throw an error when the command is `git log ...`.
        // 3. Call `getGitLog(5)`.
        // 4. Assert that the result is an empty array.
        it('should return an empty array if git log fails', async () => {});

        // TODO: Test case with an empty git log output.
        // It should return an empty array.
        // 1. Mock `exec` for worktrees.
        // 2. Mock `exec` for `git log` to return an empty string in stdout.
        // 3. Call `getGitLog(5)`.
        // 4. Assert the result is an empty array.
        it('should return an empty array for an empty git log', async () => {});
      });
    });
  test/unit/utils/fs.test.ts: >-
    import { getPhaseStats, getFailedReports, readPlan } from
    '../../../src/utils/fs';

    import fs from 'fs/promises';

    import yaml from 'js-yaml';

    import dayjs from 'dayjs';


    // TODO: Mock the 'fs/promises' module to control filesystem operations.

    jest.mock('fs/promises');

    const mockedFs = fs as jest.Mocked<typeof fs>;


    describe('utils/fs', () => {
      afterEach(() => {
        jest.clearAllMocks();
      });

      describe('getPhaseStats', () => {
        // TODO: Test case where .nocaflow directory exists with plans.
        // It should correctly count plans in todo, doing, done, etc., for each phase.
        // 1. Mock `fs.readdir` to return different arrays of filenames for different paths.
        //    - e.g., `.../initialization/plans/todo` -> `['a.yml', 'b.yml']` (count: 2)
        //    - e.g., `.../development/plans/done` -> `['c.yml']` (count: 1)
        // 2. Call `getPhaseStats()`.
        // 3. Assert `stats.initialization.todo` is 2 and `stats.development.done` is 1.
        // 4. Assert `total` is calculated correctly for each phase.
        it('should correctly count plans across different statuses and phases', async () => {});

        // TODO: Test case where a phase directory is missing.
        // It should handle the error gracefully and count as 0.
        // 1. Mock `fs.readdir` to throw an ENOENT error for any path under `.../development/...`.
        // 2. Call `getPhaseStats()`.
        // 3. Assert all counts for `development` are 0.
        it('should return 0 for a missing phase directory', async () => {});

        // TODO: Test case where a status directory is missing (e.g., no 'review' plans).
        // It should count that status as 0.
        // 1. Mock `fs.readdir` to throw an ENOENT error for `.../initialization/plans/review`.
        // 2. Call `getPhaseStats()`.
        // 3. Assert `stats.initialization.review` is 0.
        it('should return 0 for a missing status directory', async () => {});

        // TODO: Test case with an empty .nocaflow directory.
        // All counts should be 0.
        // 1. Mock `fs.readdir` to return `[]` for all status directories.
        // 2. Call `getPhaseStats()`.
        // 3. Assert all counts for all phases are 0.
        it('should return all zeros for an empty directory structure', async () => {});
      });

      describe('getFailedReports', () => {
        // TODO: Test case with recent and old failure reports.
        // It should only return reports within the specified `hours` lookback period.
        // 1. Mock `fs.readdir` to return two report files.
        // 2. Mock `fs.stat` to return a recent `birthtime` for one and an old `birthtime` for the other.
        // 3. Mock `fs.readFile` for the recent file.
        // 4. Call `getFailedReports(24)`.
        // 5. Assert the result contains only the recent report.
        it('should only return reports within the lookback period', async () => {});

        // TODO: Test case where report files have correctly formatted names and content.
        // It should correctly parse planId, partId, and summary from the filename and content.
        // 1. Mock `fs.readdir` to return `['plan1.partA.report.md']`.
        // 2. Mock `fs.stat` to return a recent `birthtime`.
        // 3. Mock `fs.readFile` to return markdown with `## Summary\nThis is the reason.`.
        // 4. Call `getFailedReports(24)`.
        // 5. Assert `result[0].planId` is 'plan1', `partId` is 'partA', and `reason` is 'This is the reason.'.
        it('should correctly parse report details', async () => {});

        // TODO: Test case with no report files.
        // It should return an empty array.
        // 1. Mock `fs.readdir` to return `[]`.
        // 2. Call `getFailedReports(24)`.
        // 3. Assert the result is an empty array.
        it('should return an empty array when no reports are found', async () => {});

        // TODO: Test case where a report file is malformed (e.g., no "## Summary" section).
        // It should handle the parsing error gracefully.
        // 1. Mock `fs.readdir` and `fs.stat` for a recent report.
        // 2. Mock `fs.readFile` to return content *without* a `## Summary` section.
        // 3. Call `getFailedReports(24)`.
        // 4. Assert the `reason` field has a sensible fallback, like 'Could not parse summary.'.
        it('should handle malformed report content', async () => {});
      });

      describe('readPlan', () => {
        // TODO: Test case with a valid YAML plan file.
        // It should correctly parse the YAML into a Plan object.
        // 1. Mock `fs.readFile` to return a valid YAML string.
        // 2. Call `readPlan('path/to/plan.yml')`.
        // 3. Assert that the returned object matches the parsed structure of the YAML.
        it('should parse a valid plan file', async () => {});

        // TODO: Test case with a non-existent file path.
        // It should throw a file-not-found error.
        // 1. Mock `fs.readFile` to throw an error with `code: 'ENOENT'`.
        // 2. Call `readPlan` and assert that it throws an error.
        it('should throw an error for a non-existent file', async () => {});

        // TODO: Test case with an invalid YAML file.
        // It should throw a YAML parsing error.
        // 1. Mock `fs.readFile` to return a string with invalid YAML syntax (e.g., `key: - invalid:`).
        // 2. Call `readPlan` and assert that it throws a YAMLException.
        it('should throw an error for invalid YAML', async () => {});
      });
    });
  test/unit/utils/shell.test.ts: |-
    import { getActiveAgents } from '../../../src/utils/shell';
    import { exec } from 'child_process';
    import dayjs from 'dayjs';

    jest.mock('child_process');
    const mockedExec = exec as jest.Mock;

    describe('utils/shell', () => {
      afterEach(() => {
        jest.clearAllMocks();
      });

      describe('getActiveAgents', () => {
        // TODO: Test case with `tmux ls` output for various agent types.
        // It should correctly parse init, dev, scaffold, and qa agents.
        // 1. Mock `exec` to return a multi-line string with session names like:
        //    - `init-part1 123 1672531200`
        //    - `dev-part2 456 1672531200`
        //    - `init-scaffold-plan1 789 1672531200`
        //    - `qa-plan2 101 1672531200`
        //    - `non-agent-session 112 1672531200`
        // 2. Call `getActiveAgents()`.
        // 3. Assert the result contains 4 agents.
        // 4. Assert each agent has the correct phase, planId, partId, etc.
        it('should parse all types of agent sessions and ignore non-agent sessions', async () => {});

        // TODO: Test case with `tmux ls` output that is empty.
        // It should return an empty array.
        // 1. Mock `exec` to return stdout as an empty string.
        // 2. Call `getActiveAgents()`.
        // 3. Assert the result is an empty array.
        it('should return an empty array when there are no tmux sessions', async () => {});

        // TODO: Test case where `tmux ls` command fails.
        // It should catch the error and return an empty array.
        // 1. Mock `exec` to throw an error.
        // 2. Call `getActiveAgents()`.
        // 3. Assert the result is an empty array.
        it('should return an empty array if tmux is not running', async () => {});

        // TODO: Test case to verify runtime calculation.
        // Mocks the current time and session activity timestamp to check the relative time string.
        // 1. Mock `Date.now` or use a time-mocking library to control "now".
        // 2. Mock `exec` to return a session with a specific activity timestamp.
        // 3. Call `getActiveAgents()`.
        // 4. Assert the `runtime` string is the expected relative time (e.g., "5 minutes").
        it('should correctly calculate agent runtime', async () => {});
      });
    });
  test/unit/utils/logs.test.ts: |-
    import { getRecentLogs } from '../../../src/utils/logs';
    import fs from 'fs/promises';

    jest.mock('fs/promises');
    const mockedFs = fs as jest.Mocked<typeof fs>;

    describe('utils/logs', () => {
      afterEach(() => {
        jest.clearAllMocks();
      });

      describe('getRecentLogs', () => {
        // TODO: Test case with multiple log files across different phases.
        // It should read from all relevant directories.
        // 1. Mock `fs.readdir` to return `['a.log']` for the init dir and `['b.log']` for the dev dir.
        // 2. Mock `fs.readFile` to return different log content for `a.log` and `b.log`.
        // 3. Call `getRecentLogs(10)`.
        // 4. Assert that the result contains parsed entries from both files.
        it('should aggregate logs from all phase directories', async () => {});

        // TODO: Test case with a log file containing valid and malformed lines.
        // It should parse valid lines and skip malformed ones.
        // 1. Mock `fs.readdir` to return one log file.
        // 2. Mock `fs.readFile` to return a string with one valid log line and one invalid line.
        // 3. Call `getRecentLogs(10)`.
        // 4. Assert that the result contains exactly one entry, corresponding to the valid line.
        it('should correctly parse valid log lines and skip invalid ones', async () => {});

        // TODO: Test case with more log entries than the specified limit.
        // It should return only the most recent 'limit' number of entries, sorted descending by timestamp.
        // 1. Mock `fs.readdir` and `fs.readFile` to produce 10 log entries with out-of-order timestamps.
        // 2. Call `getRecentLogs(5)`.
        // 3. Assert the result has a length of 5.
        // 4. Assert the timestamps in the result are in descending order.
        it('should return the correct number of recent, sorted log entries', async () => {});

        // TODO: Test case where log directories do not exist.
        // It should handle the error and return an empty array.
        // 1. Mock `fs.readdir` to throw an ENOENT error for all log directories.
        // 2. Call `getRecentLogs(5)`.
        // 3. Assert the result is an empty array.
        it('should return an empty array if log directories are missing', async () => {});

        // TODO: Test case with empty log files.
        // It should return an empty array.
        // 1. Mock `fs.readdir` to return log file names.
        // 2. Mock `fs.readFile` to return an empty string for all files.
        // 3. Call `getRecentLogs(5)`.
        // 4. Assert the result is an empty array.
        it('should return an empty array for empty log files', async () => {});
      });
    });
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: '2025-11-11T13:03:00.943Z'
status: committed
id: 10
