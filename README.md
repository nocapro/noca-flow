# Noca-Flow: Doc-Focused Workflow for Anti-Context-Rot Agent Swarms

Context rot kills parallel LLM agents. Full history to every instance is a token tax that doesn't scale. Noca-Flow fixes this. Sub-agents never lose context, living in a strict, file-based IPC structure.

## Core Idea

Agents live in docs, not context windows. They breathe YAML plans, write execution logs, communicate via filesystem. Tmux spawns them. Manager delegates easily via paths, files, and 6-digit IDs. All comms terse, HN netizen style. For isolated plan parts, git worktrees ensure clean state. No more "wait, what was I doing?" hallucinations.

# Strict Structure and naming conventions

```
noca-flow/
├── initialization/         # Phase: Boilerplate blueprint with content of only todo list comments and imports statement.
│   ├── agent-log/          # plan execution logs generated by init.agent-swarms.md
│   │   ├── 463462.log.md
│   │   └── 823523.log.md
│   ├── plan/                               # kanban yml position managed by individual init.agent-swarms.md
│   │   ├── todo/                           # yml files in todo generated by noca.agent.md using plan.prompt.md
│   │   │   ├── 463462.todo.plan.yml
│   │   │   └── 674345.todo.plan.yml
│   │   ├── doing/
│   │   │   └── 734567.doing.plan.yml
│   │   ├── review/               # files will be processed by manager.agent.md that can also spawn init.agent-swarms.md
│   │   │   ├── 463462.todo.plan.yml
│   │   │   └── 356446.review.plan.yml
│   │   ├── in-review/            # claimed lock by manager.agents.md that can also spawn another init.agent-swarms.md
│   │   │   ├── 646344.todo.plan.yml
│   │   ├── done/
│   │   │   └── 553464.done.plan.yml
│   │   └── failed/
│   │       └── 745463.failed.plan.yml
│   ├── init.agent-swarms.md                # Execute yml plan/ files while also self-manage plan/ files and agent-log
│   └── init.phase.rule.md                  # should be no isolation in this phase
├── development/            # Phase: when all yml plan/ in initialization/ are done/. then this active development for production-ready codebase, green test and zero linting problems
│   ├── agent-log/          # plan execution logs generated by dev.agent-swarms.md
│   │   ├── 4534667.log.md
│   │   └── 3646544.log.md
│   ├── plan/                               # kanban yml position managed by individual dev.agent-swarms.md
│   │   ├── todo/                           # yml files in todo generated by noca.agent.md using plan.prompt.md
│   │   │   ├── 3646544.todo.plan.yml
│   │   │   └── 4534667.todo.plan.yml
│   │   ├── doing/
│   │   │   └── 2145365.doing.plan.yml
│   │   ├── review/               # files will be processed by manager.agents.md that can also spawn dev.agent-swarms.md
│   │   │   ├── 8797645.todo.plan.yml
│   │   │   └── 2345357.review.plan.yml
│   │   ├── in-review/            # claimed lock by manager.agents.md that can also spawn another init.agent-swarms.md
│   │   │   ├── 4634623.todo.plan.yml
│   │   ├── done/
│   │   │   └── 4574743.done.plan.yml
│   │   └── failed/
│   │       └── 4567454.failed.plan.yml
│   ├── dev.agent-swarms.md                # Execute yml plan/ files while also self-manage plan/ files and agent-log
│   └── dev.phase.rule.md                  # should be no isolation in this phase
├── plan.agents.md                          # Focus on generating plan/ yml todo files based on user input using plan.prompt.md
├── plan.prompt.md
├── manager.agents.md                       #
├── manager.prompt.md
└──
```

## Workflow

1. **Plan**: `plan.agents.md` reads prompt → dumps YAML in `initialization/plan/todo/`
2. **Claim**: `init.agent-swarms.md` grabs plan, moves to `doing/`, spawns tmux session
3. **Execute**: Agent writes log, modifies files, updates plan status
4. **Review**: Manager moves to `review/` or `done/`; spawns new agents if needed
5. **Isolate**: When `plan.parts.isolation: true`, uses git worktree for clean state

## Comms Style

All dialogue in HN netizen style. Terse. No fluff. Example:

> "Part 1 step 2 fails on nested gitignore. Pushed fix to 463462.log.md. Moved plan to review."

## Plan Format

```yaml
plan:
  uuid: 'c8a2b1f0-4d5e-4b9c-8a7f-6e5d4c3b2a1f'
  status: 'todo'
  title: 'Fix recursive gitignore'
  parts:
    - uuid: '9e7f8a7b-6c5d-4a3b-2c1d-0e9f8a7b6c5d'
      status: 'todo'
      name: 'Implement true recursive handling'
      steps:
        - uuid: 'a1b2c3d4-e5f6-4a3b-8c7d-6e5f4a9b8c7d'
          status: 'todo'
          name: '1. Introduce createProjectIgnoreFilter'
          files: ['src/lib/gitignore-parser.ts']
          operations: ['Add simpleWalk helper', 'Parse all nested .gitignore files']
      context_files:
        compact: ['src/lib/gitignore-parser.ts']
        extended: ['src/lib/gitignore-parser.ts', 'tests/']
  conclusion: 'Hardens core filesystem logic. No more context pollution.'
```

## Rules

- **IDs**: 6-digit for humans, UUID for machines. Never guess.
- **Isolation**: `false` in init/dev phases. Worktrees are for plan parts only.
- **Logs**: Timestamped, agent-scoped, `.log.md` format.
- **State**: Single source of truth is the plan YAML, not agent memory.

## Tradeoffs

FS I/O overhead vs token savings. For swarms running >10 minutes, it's a no-brainer. You pay milliseconds on disk to save thousands in context.

Now go build something that doesn't rot.
